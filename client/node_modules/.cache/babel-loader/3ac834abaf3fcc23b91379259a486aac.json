{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractWrapper = void 0;\n\nvar path_1 = __importDefault(require(\"path\"));\n\nvar fs_1 = __importDefault(require(\"fs\"));\n\nvar __1 = require(\"..\");\n\nvar chainSendContext_1 = require(\"./chainSendContext\");\n\nvar generateMethods_1 = require(\"./generateMethods\");\n\nvar formattedCall_1 = require(\"./formattedCall\");\n\nvar argumentErrorContext_1 = require(\"../argumentErrorContext\");\n\nvar __2 = require(\"../..\");\n\nvar preparedCall_1 = require(\"./preparedCall\");\n\nvar _1 = require(\".\");\n\nvar testutils_1 = require(\"../../testutils\");\n/**\n * Provides a simple interface in order to easily call or query the smart contract's methods.\n */\n\n\nvar ContractWrapper = /*#__PURE__*/function (_chainSendContext_1$C) {\n  _inherits(ContractWrapper, _chainSendContext_1$C);\n\n  var _super = _createSuper(ContractWrapper);\n\n  function ContractWrapper(smartContract, abi, wasmPath, context, builtinFunctions) {\n    var _this;\n\n    _classCallCheck(this, ContractWrapper);\n\n    _this = _super.call(this, context);\n    _this.context = context;\n    _this.smartContract = smartContract;\n    _this.abi = abi;\n    _this.wasmPath = wasmPath;\n    _this.builtinFunctions = builtinFunctions || _assertThisInitialized(_this);\n    _this.call = generateMethods_1.generateMethods(_assertThisInitialized(_this), _this.abi, _this.handleCall);\n    _this.results = generateMethods_1.generateMethods(_assertThisInitialized(_this), _this.abi, _this.handleResults);\n    _this.query = generateMethods_1.generateMethods(_assertThisInitialized(_this), _this.abi, _this.handleQuery);\n    _this.format = generateMethods_1.generateMethods(_assertThisInitialized(_this), _this.abi, _this.handleFormat);\n\n    var constructor = _this.abi.getConstructorDefinition();\n\n    if (constructor !== null) {\n      _this.call.deploy = _this.handleDeployCall.bind(_assertThisInitialized(_this), constructor);\n      _this.format.deploy = _this.handleFormat.bind(_assertThisInitialized(_this), constructor);\n    }\n\n    return _this;\n  }\n\n  _createClass(ContractWrapper, [{\n    key: \"address\",\n    value: function address(_address) {\n      var typedAddress = __1.NativeSerializer.convertNativeToAddress(_address, new argumentErrorContext_1.ArgumentErrorContext(\"address\", \"0\", new __1.EndpointParameterDefinition(\"address\", \"\", new __1.AddressType())));\n\n      this.smartContract.setAddress(typedAddress);\n      return this;\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return this.smartContract.getAddress();\n    }\n  }, {\n    key: \"getAbi\",\n    value: function getAbi() {\n      return this.abi;\n    }\n  }, {\n    key: \"getSmartContract\",\n    value: function getSmartContract() {\n      return this.smartContract;\n    }\n  }, {\n    key: \"getCode\",\n    value: function getCode() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.wasmPath == null)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw new __2.Err(\"contract wasm path not configured\");\n\n              case 2:\n                _context.next = 4;\n                return testutils_1.loadContractCode(this.wasmPath);\n\n              case 4:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"buildDeployTransaction\",\n    value: function buildDeployTransaction(constructorDefinition, args) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var contractCode, convertedArgs, transaction;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getCode();\n\n              case 2:\n                contractCode = _context2.sent;\n                convertedArgs = formattedCall_1.formatEndpoint.apply(formattedCall_1, [constructorDefinition, constructorDefinition].concat(_toConsumableArray(args))).toTypedValues();\n                transaction = this.smartContract.deploy({\n                  code: contractCode,\n                  gasLimit: this.context.getGasLimit(),\n                  initArguments: convertedArgs\n                });\n                return _context2.abrupt(\"return\", transaction);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"handleDeployCall\",\n    value: function handleDeployCall(constructorDefinition) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var transaction, transactionOnNetwork, smartContractResults, immediateResult, logger;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.buildDeployTransaction(constructorDefinition, args);\n\n              case 2:\n                transaction = _context3.sent;\n                _context3.next = 5;\n                return this.processTransaction(transaction);\n\n              case 5:\n                transactionOnNetwork = _context3.sent;\n                smartContractResults = transactionOnNetwork.getSmartContractResults();\n                immediateResult = smartContractResults.getImmediate();\n                immediateResult.assertSuccess();\n                logger = this.context.getLogger();\n                logger === null || logger === void 0 ? void 0 : logger.deployComplete(transaction, smartContractResults, this.smartContract.getAddress());\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"handleQuery\",\n    value: function handleQuery(endpoint) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var preparedCall, interaction, provider, logger, query, optionalSender, response, queryResponseBundle, result;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.prepareCallWithPayment(endpoint, args);\n\n              case 2:\n                preparedCall = _context4.sent;\n                interaction = this.convertPreparedCallToInteraction(preparedCall);\n                provider = this.context.getProvider();\n                logger = this.context.getLogger();\n                query = interaction.buildQuery();\n                logger === null || logger === void 0 ? void 0 : logger.queryCreated(query);\n                optionalSender = this.context.getSenderOptional();\n\n                if (optionalSender != null) {\n                  query.caller = optionalSender.address;\n                }\n\n                _context4.next = 12;\n                return provider.queryContract(query);\n\n              case 12:\n                response = _context4.sent;\n                console.log(\"got response...\", response);\n                queryResponseBundle = interaction.interpretQueryResponse(response);\n                result = queryResponseBundle.queryResponse.unpackOutput();\n                logger === null || logger === void 0 ? void 0 : logger.queryComplete(result, response);\n                return _context4.abrupt(\"return\", result);\n\n              case 18:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"handleCall\",\n    value: function handleCall(endpoint) {\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this$buildTransactio, transaction, interaction, _yield$this$processTr, result;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _this$buildTransactio = this.buildTransactionAndInteraction(endpoint, args), transaction = _this$buildTransactio.transaction, interaction = _this$buildTransactio.interaction;\n                _context5.next = 3;\n                return this.processTransactionAndInterpretResults({\n                  transaction: transaction,\n                  interaction: interaction\n                });\n\n              case 3:\n                _yield$this$processTr = _context5.sent;\n                result = _yield$this$processTr.result;\n                return _context5.abrupt(\"return\", result);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"handleResults\",\n    value: function handleResults(endpoint) {\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this$buildTransactio2, transaction, interaction, _yield$this$processTr2, executionResultsBundle;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _this$buildTransactio2 = this.buildTransactionAndInteraction(endpoint, args), transaction = _this$buildTransactio2.transaction, interaction = _this$buildTransactio2.interaction;\n                _context6.next = 3;\n                return this.processTransactionAndInterpretResults({\n                  transaction: transaction,\n                  interaction: interaction\n                });\n\n              case 3:\n                _yield$this$processTr2 = _context6.sent;\n                executionResultsBundle = _yield$this$processTr2.executionResultsBundle;\n                return _context6.abrupt(\"return\", executionResultsBundle);\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"processTransactionAndInterpretResults\",\n    value: function processTransactionAndInterpretResults(_ref) {\n      var transaction = _ref.transaction,\n          interaction = _ref.interaction;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var transactionOnNetwork, executionResultsBundle, smartContractResults, immediateResult, result, logger;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.processTransaction(transaction);\n\n              case 2:\n                transactionOnNetwork = _context7.sent;\n                executionResultsBundle = interaction.interpretExecutionResults(transactionOnNetwork);\n                smartContractResults = executionResultsBundle.smartContractResults, immediateResult = executionResultsBundle.immediateResult;\n                result = immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.unpackOutput();\n                logger = this.context.getLogger();\n                logger === null || logger === void 0 ? void 0 : logger.transactionComplete(result, immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.data, transaction, smartContractResults);\n                return _context7.abrupt(\"return\", {\n                  executionResultsBundle: executionResultsBundle,\n                  result: result\n                });\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"processTransaction\",\n    value: function processTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var provider, sender, logger, transactionOnNetwork;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                provider = this.context.getProvider();\n                sender = this.context.getSender();\n                transaction.setNonce(sender.account.nonce);\n                _context8.next = 5;\n                return sender.signer.sign(transaction);\n\n              case 5:\n                logger = this.context.getLogger();\n                logger === null || logger === void 0 ? void 0 : logger.transactionCreated(transaction);\n                _context8.next = 9;\n                return transaction.send(provider);\n\n              case 9:\n                // increment the nonce only after the transaction is sent\n                // since an exception thrown by the provider means we will have to re-use the same nonce\n                // otherwise the next transactions will hang (and never complete)\n                sender.account.incrementNonce();\n                logger === null || logger === void 0 ? void 0 : logger.transactionSent(transaction);\n                _context8.next = 13;\n                return transaction.awaitExecuted(provider);\n\n              case 13:\n                _context8.next = 15;\n                return transaction.getAsOnNetwork(provider, true, false, true);\n\n              case 15:\n                transactionOnNetwork = _context8.sent;\n\n                if (!transaction.getStatus().isFailed()) {\n                  _context8.next = 18;\n                  break;\n                }\n\n                throw new __2.ErrContract(\"Transaction status failed: [\".concat(transaction.getStatus().toString(), \"].\"));\n\n              case 18:\n                return _context8.abrupt(\"return\", transactionOnNetwork);\n\n              case 19:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"handleFormat\",\n    value: function handleFormat(endpoint) {\n      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      var _this$prepareCallWith = this.prepareCallWithPayment(endpoint, args),\n          formattedCall = _this$prepareCallWith.formattedCall;\n\n      return formattedCall;\n    }\n  }, {\n    key: \"buildTransactionAndInteraction\",\n    value: function buildTransactionAndInteraction(endpoint, args) {\n      var preparedCall = this.prepareCallWithPayment(endpoint, args);\n      var interaction = this.convertPreparedCallToInteraction(preparedCall);\n      interaction.withGasLimit(this.context.getGasLimit());\n      var transaction = interaction.buildTransaction();\n      return {\n        transaction: transaction,\n        interaction: interaction\n      };\n    }\n  }, {\n    key: \"prepareCallWithPayment\",\n    value: function prepareCallWithPayment(endpoint, args) {\n      var value = this.context.getAndResetValue();\n\n      if (value == null && endpoint.modifiers.isPayable()) {\n        throw new __2.Err(\"Did not provide any value for a payable method\");\n      }\n\n      if (value != null && !endpoint.modifiers.isPayable()) {\n        throw new __2.Err(\"A value was provided for a non-payable method\");\n      }\n\n      if (value != null && !endpoint.modifiers.isPayableInToken(value.token.getTokenIdentifier())) {\n        throw new __2.Err(\"Token \".concat(value.token.getTokenIdentifier(), \" is not accepted by payable method. Accepted tokens: \").concat(endpoint.modifiers.payableInTokens));\n      }\n\n      var formattedCall = formattedCall_1.formatEndpoint.apply(formattedCall_1, [endpoint, endpoint].concat(_toConsumableArray(args)));\n      var preparedCall = new preparedCall_1.PreparedCall(this.smartContract.getAddress(), __2.Egld(0), formattedCall);\n      this.applyValueModfiers(value, preparedCall);\n      return preparedCall;\n    }\n  }, {\n    key: \"convertPreparedCallToInteraction\",\n    value: function convertPreparedCallToInteraction(preparedCall) {\n      var executingFunction = preparedCall.formattedCall.getExecutingFunction();\n      var interpretingFunction = preparedCall.formattedCall.getInterpretingFunction();\n      var typedValueArgs = preparedCall.formattedCall.toTypedValues();\n      var interaction = new __1.Interaction(this.smartContract, executingFunction, interpretingFunction, typedValueArgs, preparedCall.receiver);\n      interaction.withValue(preparedCall.egldValue);\n      return interaction;\n    }\n  }, {\n    key: \"applyValueModfiers\",\n    value: function applyValueModfiers(value, preparedCall) {\n      if (value == null) {\n        return;\n      }\n\n      if (value.token.isEgld()) {\n        preparedCall.egldValue = value;\n        return;\n      }\n\n      if (value.token.isFungible()) {\n        preparedCall.wrap(this.builtinFunctions.format.ESDTTransfer(value.token.getTokenIdentifier(), value.valueOf(), preparedCall.formattedCall));\n      } else {\n        preparedCall.receiver = this.context.getSender().address;\n        preparedCall.wrap(this.builtinFunctions.format.ESDTNFTTransfer(value.token.getTokenIdentifier(), value.getNonce(), value.valueOf(), this.smartContract, preparedCall.formattedCall));\n      }\n    }\n  }], [{\n    key: \"loadProject\",\n    value: function loadProject(provider, builtinFunctions, projectPath, filenameHint, sendContext) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _yield$expandProjectP, abiPath, wasmPath, abi, smartContract;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return expandProjectPath(projectPath, filenameHint);\n\n              case 2:\n                _yield$expandProjectP = _context9.sent;\n                abiPath = _yield$expandProjectP.abiPath;\n                wasmPath = _yield$expandProjectP.wasmPath;\n                _context9.next = 7;\n                return __1.SmartContractAbi.fromAbiPath(abiPath);\n\n              case 7:\n                abi = _context9.sent;\n                smartContract = new __1.SmartContract({\n                  abi: abi\n                });\n                sendContext = sendContext || new _1.SendContext(provider).logger(new _1.ContractLogger());\n                return _context9.abrupt(\"return\", new ContractWrapper(smartContract, abi, wasmPath, sendContext, builtinFunctions));\n\n              case 11:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n    }\n  }]);\n\n  return ContractWrapper;\n}(chainSendContext_1.ChainSendContext);\n\nexports.ContractWrapper = ContractWrapper;\n\nfunction filterByExtension(fileList, extension) {\n  return fileList.filter(function (name) {\n    return name.endsWith(extension);\n  });\n}\n\nfunction filterByFilename(fileList, filename) {\n  return fileList.filter(function (name) {\n    return name == filename;\n  });\n} // Compiling creates a temporary file which sometimes doesn't get deleted. It should be ignored.\n\n\nfunction ignoreTemporaryWasmFiles(fileList) {\n  var temporaryWasmFiles = filterByExtension(fileList, \"_wasm.wasm\");\n  var difference = fileList.filter(function (file) {\n    return temporaryWasmFiles.indexOf(file) === -1;\n  });\n  return difference;\n}\n\nfunction filterWithHint(fileList, extension, filenameHint) {\n  if (filenameHint) {\n    var pattern = filenameHint + extension;\n    return {\n      pattern: pattern,\n      filteredFileList: filterByFilename(fileList, pattern)\n    };\n  }\n\n  return {\n    pattern: \"*\" + extension,\n    filteredFileList: filterByExtension(fileList, extension)\n  };\n}\n\nfunction getFileByExtension(fileList, folderPath, extension, filenameHint) {\n  var _filterWithHint = filterWithHint(fileList, extension, filenameHint),\n      pattern = _filterWithHint.pattern,\n      filteredFileList = _filterWithHint.filteredFileList;\n\n  if (filteredFileList.length != 1) {\n    throw new __2.ErrInvalidArgument(\"Expected a single \".concat(pattern, \" file in \").concat(folderPath, \" (found \").concat(filteredFileList.length, \")\"));\n  }\n\n  return path_1.default.join(folderPath, filteredFileList[0]);\n}\n\nfunction getAbiAndWasmPaths(outputPath, filenameHint) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n    var filesInOutput, abiPath, wasmPath;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return fs_1.default.promises.readdir(outputPath);\n\n          case 2:\n            filesInOutput = _context10.sent;\n            filesInOutput = ignoreTemporaryWasmFiles(filesInOutput);\n            abiPath = getFileByExtension(filesInOutput, outputPath, \".abi.json\", filenameHint);\n\n            try {\n              wasmPath = getFileByExtension(filesInOutput, outputPath, \".wasm\", filenameHint);\n            } catch (_) {\n              wasmPath = null;\n            }\n\n            return _context10.abrupt(\"return\", {\n              abiPath: abiPath,\n              wasmPath: wasmPath\n            });\n\n          case 7:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n}\n\nfunction expandProjectPath(projectPath, filenameHint) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n    var outputPath;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            projectPath = path_1.default.resolve(projectPath);\n            _context11.prev = 1;\n            _context11.next = 4;\n            return getAbiAndWasmPaths(projectPath, filenameHint);\n\n          case 4:\n            return _context11.abrupt(\"return\", _context11.sent);\n\n          case 7:\n            _context11.prev = 7;\n            _context11.t0 = _context11[\"catch\"](1);\n            outputPath = path_1.default.join(projectPath, \"output\");\n            _context11.next = 12;\n            return getAbiAndWasmPaths(outputPath, filenameHint);\n\n          case 12:\n            return _context11.abrupt(\"return\", _context11.sent);\n\n          case 13:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11, null, [[1, 7]]);\n  }));\n}","map":{"version":3,"sources":["../../../src/smartcontracts/wrapper/contractWrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContractWrapper = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst __1 = require(\"..\");\nconst chainSendContext_1 = require(\"./chainSendContext\");\nconst generateMethods_1 = require(\"./generateMethods\");\nconst formattedCall_1 = require(\"./formattedCall\");\nconst argumentErrorContext_1 = require(\"../argumentErrorContext\");\nconst __2 = require(\"../..\");\nconst preparedCall_1 = require(\"./preparedCall\");\nconst _1 = require(\".\");\nconst testutils_1 = require(\"../../testutils\");\n/**\n * Provides a simple interface in order to easily call or query the smart contract's methods.\n */\nclass ContractWrapper extends chainSendContext_1.ChainSendContext {\n    constructor(smartContract, abi, wasmPath, context, builtinFunctions) {\n        super(context);\n        this.context = context;\n        this.smartContract = smartContract;\n        this.abi = abi;\n        this.wasmPath = wasmPath;\n        this.builtinFunctions = builtinFunctions || this;\n        this.call = generateMethods_1.generateMethods(this, this.abi, this.handleCall);\n        this.results = generateMethods_1.generateMethods(this, this.abi, this.handleResults);\n        this.query = generateMethods_1.generateMethods(this, this.abi, this.handleQuery);\n        this.format = generateMethods_1.generateMethods(this, this.abi, this.handleFormat);\n        let constructor = this.abi.getConstructorDefinition();\n        if (constructor !== null) {\n            this.call.deploy = this.handleDeployCall.bind(this, constructor);\n            this.format.deploy = this.handleFormat.bind(this, constructor);\n        }\n    }\n    address(address) {\n        let typedAddress = __1.NativeSerializer.convertNativeToAddress(address, new argumentErrorContext_1.ArgumentErrorContext(\"address\", \"0\", new __1.EndpointParameterDefinition(\"address\", \"\", new __1.AddressType())));\n        this.smartContract.setAddress(typedAddress);\n        return this;\n    }\n    getAddress() {\n        return this.smartContract.getAddress();\n    }\n    getAbi() {\n        return this.abi;\n    }\n    getSmartContract() {\n        return this.smartContract;\n    }\n    getCode() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.wasmPath == null) {\n                throw new __2.Err(\"contract wasm path not configured\");\n            }\n            return yield testutils_1.loadContractCode(this.wasmPath);\n        });\n    }\n    buildDeployTransaction(constructorDefinition, args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let contractCode = yield this.getCode();\n            let convertedArgs = formattedCall_1.formatEndpoint(constructorDefinition, constructorDefinition, ...args).toTypedValues();\n            let transaction = this.smartContract.deploy({\n                code: contractCode,\n                gasLimit: this.context.getGasLimit(),\n                initArguments: convertedArgs\n            });\n            return transaction;\n        });\n    }\n    handleDeployCall(constructorDefinition, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let transaction = yield this.buildDeployTransaction(constructorDefinition, args);\n            let transactionOnNetwork = yield this.processTransaction(transaction);\n            let smartContractResults = transactionOnNetwork.getSmartContractResults();\n            let immediateResult = smartContractResults.getImmediate();\n            immediateResult.assertSuccess();\n            let logger = this.context.getLogger();\n            logger === null || logger === void 0 ? void 0 : logger.deployComplete(transaction, smartContractResults, this.smartContract.getAddress());\n        });\n    }\n    static loadProject(provider, builtinFunctions, projectPath, filenameHint, sendContext) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { abiPath, wasmPath } = yield expandProjectPath(projectPath, filenameHint);\n            let abi = yield __1.SmartContractAbi.fromAbiPath(abiPath);\n            let smartContract = new __1.SmartContract({ abi: abi });\n            sendContext = sendContext || new _1.SendContext(provider).logger(new _1.ContractLogger());\n            return new ContractWrapper(smartContract, abi, wasmPath, sendContext, builtinFunctions);\n        });\n    }\n    handleQuery(endpoint, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let preparedCall = yield this.prepareCallWithPayment(endpoint, args);\n            let interaction = this.convertPreparedCallToInteraction(preparedCall);\n            let provider = this.context.getProvider();\n            let logger = this.context.getLogger();\n            let query = interaction.buildQuery();\n            logger === null || logger === void 0 ? void 0 : logger.queryCreated(query);\n            let optionalSender = this.context.getSenderOptional();\n            if (optionalSender != null) {\n                query.caller = optionalSender.address;\n            }\n            let response = yield provider.queryContract(query);\n            console.log(\"got response...\", response);\n            let queryResponseBundle = interaction.interpretQueryResponse(response);\n            let result = queryResponseBundle.queryResponse.unpackOutput();\n            logger === null || logger === void 0 ? void 0 : logger.queryComplete(result, response);\n            return result;\n        });\n    }\n    handleCall(endpoint, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { transaction, interaction } = this.buildTransactionAndInteraction(endpoint, args);\n            let { result } = yield this.processTransactionAndInterpretResults({ transaction, interaction });\n            return result;\n        });\n    }\n    handleResults(endpoint, ...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { transaction, interaction } = this.buildTransactionAndInteraction(endpoint, args);\n            let { executionResultsBundle } = yield this.processTransactionAndInterpretResults({ transaction, interaction });\n            return executionResultsBundle;\n        });\n    }\n    processTransactionAndInterpretResults({ transaction, interaction }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let transactionOnNetwork = yield this.processTransaction(transaction);\n            let executionResultsBundle = interaction.interpretExecutionResults(transactionOnNetwork);\n            let { smartContractResults, immediateResult } = executionResultsBundle;\n            let result = immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.unpackOutput();\n            let logger = this.context.getLogger();\n            logger === null || logger === void 0 ? void 0 : logger.transactionComplete(result, immediateResult === null || immediateResult === void 0 ? void 0 : immediateResult.data, transaction, smartContractResults);\n            return { executionResultsBundle, result };\n        });\n    }\n    processTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let provider = this.context.getProvider();\n            let sender = this.context.getSender();\n            transaction.setNonce(sender.account.nonce);\n            yield sender.signer.sign(transaction);\n            let logger = this.context.getLogger();\n            logger === null || logger === void 0 ? void 0 : logger.transactionCreated(transaction);\n            yield transaction.send(provider);\n            // increment the nonce only after the transaction is sent\n            // since an exception thrown by the provider means we will have to re-use the same nonce\n            // otherwise the next transactions will hang (and never complete)\n            sender.account.incrementNonce();\n            logger === null || logger === void 0 ? void 0 : logger.transactionSent(transaction);\n            yield transaction.awaitExecuted(provider);\n            let transactionOnNetwork = yield transaction.getAsOnNetwork(provider, true, false, true);\n            if (transaction.getStatus().isFailed()) {\n                // TODO: extract the error messages\n                //let results = transactionOnNetwork.getSmartContractResults().getAllResults();\n                //let messages = results.map((result) => console.log(result));\n                throw new __2.ErrContract(`Transaction status failed: [${transaction.getStatus().toString()}].`); // Return messages:\\n${messages}`);\n            }\n            return transactionOnNetwork;\n        });\n    }\n    handleFormat(endpoint, ...args) {\n        let { formattedCall } = this.prepareCallWithPayment(endpoint, args);\n        return formattedCall;\n    }\n    buildTransactionAndInteraction(endpoint, args) {\n        let preparedCall = this.prepareCallWithPayment(endpoint, args);\n        let interaction = this.convertPreparedCallToInteraction(preparedCall);\n        interaction.withGasLimit(this.context.getGasLimit());\n        let transaction = interaction.buildTransaction();\n        return { transaction, interaction };\n    }\n    prepareCallWithPayment(endpoint, args) {\n        let value = this.context.getAndResetValue();\n        if (value == null && endpoint.modifiers.isPayable()) {\n            throw new __2.Err(\"Did not provide any value for a payable method\");\n        }\n        if (value != null && !endpoint.modifiers.isPayable()) {\n            throw new __2.Err(\"A value was provided for a non-payable method\");\n        }\n        if (value != null && !endpoint.modifiers.isPayableInToken(value.token.getTokenIdentifier())) {\n            throw new __2.Err(`Token ${value.token.getTokenIdentifier()} is not accepted by payable method. Accepted tokens: ${endpoint.modifiers.payableInTokens}`);\n        }\n        let formattedCall = formattedCall_1.formatEndpoint(endpoint, endpoint, ...args);\n        let preparedCall = new preparedCall_1.PreparedCall(this.smartContract.getAddress(), __2.Egld(0), formattedCall);\n        this.applyValueModfiers(value, preparedCall);\n        return preparedCall;\n    }\n    convertPreparedCallToInteraction(preparedCall) {\n        let executingFunction = preparedCall.formattedCall.getExecutingFunction();\n        let interpretingFunction = preparedCall.formattedCall.getInterpretingFunction();\n        let typedValueArgs = preparedCall.formattedCall.toTypedValues();\n        let interaction = new __1.Interaction(this.smartContract, executingFunction, interpretingFunction, typedValueArgs, preparedCall.receiver);\n        interaction.withValue(preparedCall.egldValue);\n        return interaction;\n    }\n    applyValueModfiers(value, preparedCall) {\n        if (value == null) {\n            return;\n        }\n        if (value.token.isEgld()) {\n            preparedCall.egldValue = value;\n            return;\n        }\n        if (value.token.isFungible()) {\n            preparedCall.wrap(this.builtinFunctions.format.ESDTTransfer(value.token.getTokenIdentifier(), value.valueOf(), preparedCall.formattedCall));\n        }\n        else {\n            preparedCall.receiver = this.context.getSender().address;\n            preparedCall.wrap(this.builtinFunctions.format.ESDTNFTTransfer(value.token.getTokenIdentifier(), value.getNonce(), value.valueOf(), this.smartContract, preparedCall.formattedCall));\n        }\n    }\n}\nexports.ContractWrapper = ContractWrapper;\nfunction filterByExtension(fileList, extension) {\n    return fileList.filter(name => name.endsWith(extension));\n}\nfunction filterByFilename(fileList, filename) {\n    return fileList.filter(name => name == filename);\n}\n// Compiling creates a temporary file which sometimes doesn't get deleted. It should be ignored.\nfunction ignoreTemporaryWasmFiles(fileList) {\n    let temporaryWasmFiles = filterByExtension(fileList, \"_wasm.wasm\");\n    let difference = fileList.filter(file => temporaryWasmFiles.indexOf(file) === -1);\n    return difference;\n}\nfunction filterWithHint(fileList, extension, filenameHint) {\n    if (filenameHint) {\n        let pattern = filenameHint + extension;\n        return {\n            pattern,\n            filteredFileList: filterByFilename(fileList, pattern)\n        };\n    }\n    return {\n        pattern: \"*\" + extension,\n        filteredFileList: filterByExtension(fileList, extension)\n    };\n}\nfunction getFileByExtension(fileList, folderPath, extension, filenameHint) {\n    let { pattern, filteredFileList } = filterWithHint(fileList, extension, filenameHint);\n    if (filteredFileList.length != 1) {\n        throw new __2.ErrInvalidArgument(`Expected a single ${pattern} file in ${folderPath} (found ${filteredFileList.length})`);\n    }\n    return path_1.default.join(folderPath, filteredFileList[0]);\n}\nfunction getAbiAndWasmPaths(outputPath, filenameHint) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let filesInOutput = yield fs_1.default.promises.readdir(outputPath);\n        filesInOutput = ignoreTemporaryWasmFiles(filesInOutput);\n        let abiPath = getFileByExtension(filesInOutput, outputPath, \".abi.json\", filenameHint);\n        let wasmPath;\n        try {\n            wasmPath = getFileByExtension(filesInOutput, outputPath, \".wasm\", filenameHint);\n        }\n        catch (_) {\n            wasmPath = null;\n        }\n        return { abiPath, wasmPath };\n    });\n}\nfunction expandProjectPath(projectPath, filenameHint) {\n    return __awaiter(this, void 0, void 0, function* () {\n        projectPath = path_1.default.resolve(projectPath);\n        try {\n            return yield getAbiAndWasmPaths(projectPath, filenameHint);\n        }\n        catch (_) {\n            let outputPath = path_1.default.join(projectPath, \"output\");\n            return yield getAbiAndWasmPaths(outputPath, filenameHint);\n        }\n    });\n}\n//# sourceMappingURL=contractWrapper.js.map"]},"metadata":{},"sourceType":"script"}