{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FormattedCall = exports.formatEndpoint = void 0;\n\nvar __1 = require(\"..\");\n/**\n * Creates a FormattedCall from the given endpoint and args.\n */\n\n\nfunction formatEndpoint(executingEndpoint, interpretingEndpoint) {\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n\n  return new FormattedCall(executingEndpoint, interpretingEndpoint, args);\n}\n\nexports.formatEndpoint = formatEndpoint;\n/**\n * Formats and validates the arguments of a bound call.\n * A bound call is represented by a function and its arguments packed together.\n * A function is defined as something that has an EndpointDefinition and may be:\n * - a smart contract method\n * - a built-in function (such as an ESDT transfer)\n */\n\nvar FormattedCall = /*#__PURE__*/function () {\n  function FormattedCall(executingEndpoint, interpretingEndpoint, args) {\n    _classCallCheck(this, FormattedCall);\n\n    this.executingEndpoint = executingEndpoint;\n    this.interpretingEndpoint = interpretingEndpoint;\n    this.args = args;\n  }\n\n  _createClass(FormattedCall, [{\n    key: \"getExecutingFunction\",\n    value: function getExecutingFunction() {\n      return new __1.ContractFunction(this.executingEndpoint.name);\n    }\n  }, {\n    key: \"getInterpretingFunction\",\n    value: function getInterpretingFunction() {\n      return new __1.ContractFunction(this.interpretingEndpoint.name);\n    }\n    /**\n     * Takes the given arguments, and converts them to typed values, validating them against the given endpoint in the process.\n     */\n\n  }, {\n    key: \"toTypedValues\",\n    value: function toTypedValues() {\n      var expandedArgs = this.getExpandedArgs();\n      return __1.NativeSerializer.nativeToTypedValues(expandedArgs, this.executingEndpoint);\n    }\n  }, {\n    key: \"toArgBuffers\",\n    value: function toArgBuffers() {\n      var typedValues = this.toTypedValues();\n      return new __1.ArgSerializer().valuesToBuffers(typedValues);\n    }\n    /**\n     * Formats the function name and its arguments as an array of buffers.\n     * This is useful for nested calls (for the multisig smart contract or for ESDT transfers).\n     * A formatted deploy call does not return the function name.\n     */\n\n  }, {\n    key: \"toCallBuffers\",\n    value: function toCallBuffers() {\n      if (this.executingEndpoint.isConstructor()) {\n        return this.toArgBuffers();\n      }\n\n      return [Buffer.from(this.executingEndpoint.name)].concat(_toConsumableArray(this.toArgBuffers()));\n    }\n  }, {\n    key: \"getExpandedArgs\",\n    value: function getExpandedArgs() {\n      var expanded = [];\n\n      var _iterator = _createForOfIteratorHelper(this.args),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var value = _step.value;\n\n          if (value instanceof FormattedCall) {\n            expanded = expanded.concat(value.toCallBuffers());\n          } else {\n            expanded.push(value);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return expanded;\n    }\n  }]);\n\n  return FormattedCall;\n}();\n\nexports.FormattedCall = FormattedCall;","map":{"version":3,"sources":["../../../src/smartcontracts/wrapper/formattedCall.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,IAAA,GAAA,GAAA,OAAA,CAAA,IAAA,CAAA;AAEA;;AAEG;;;AACH,SAAgB,cAAhB,CAA+B,iBAA/B,EAAsE,oBAAtE,EAA8H;AAAA,oCAAX,IAAW;AAAX,IAAA,IAAW;AAAA;;AAC1H,SAAO,IAAI,aAAJ,CAAkB,iBAAlB,EAAqC,oBAArC,EAA2D,IAA3D,CAAP;AACH;;AAFD,OAAA,CAAA,cAAA,GAAA,cAAA;AAIA;;;;;;AAMG;;IACU,a;AAKT,yBAAY,iBAAZ,EAAmD,oBAAnD,EAA6F,IAA7F,EAAwG;AAAA;;AACpG,SAAK,iBAAL,GAAyB,iBAAzB;AACA,SAAK,oBAAL,GAA4B,oBAA5B;AACA,SAAK,IAAL,GAAY,IAAZ;AACH;;;;WAED,gCAAoB;AAChB,aAAO,IAAI,GAAA,CAAA,gBAAJ,CAAqB,KAAK,iBAAL,CAAuB,IAA5C,CAAP;AACH;;;WAED,mCAAuB;AACnB,aAAO,IAAI,GAAA,CAAA,gBAAJ,CAAqB,KAAK,oBAAL,CAA0B,IAA/C,CAAP;AACH;AAED;;AAEG;;;;WACH,yBAAa;AACT,UAAI,YAAY,GAAG,KAAK,eAAL,EAAnB;AACA,aAAO,GAAA,CAAA,gBAAA,CAAiB,mBAAjB,CAAqC,YAArC,EAAmD,KAAK,iBAAxD,CAAP;AACH;;;WAED,wBAAY;AACR,UAAI,WAAW,GAAG,KAAK,aAAL,EAAlB;AACA,aAAO,IAAI,GAAA,CAAA,aAAJ,GAAoB,eAApB,CAAoC,WAApC,CAAP;AACH;AAED;;;;AAIG;;;;WACH,yBAAa;AACT,UAAI,KAAK,iBAAL,CAAuB,aAAvB,EAAJ,EAA4C;AACxC,eAAO,KAAK,YAAL,EAAP;AACH;;AACD,cAAQ,MAAM,CAAC,IAAP,CAAY,KAAK,iBAAL,CAAuB,IAAnC,CAAR,4BAAqD,KAAK,YAAL,EAArD;AACH;;;WAEO,2BAAe;AACnB,UAAI,QAAQ,GAAU,EAAtB;;AADmB,iDAED,KAAK,IAFJ;AAAA;;AAAA;AAEnB,4DAA6B;AAAA,cAApB,KAAoB;;AACzB,cAAI,KAAK,YAAY,aAArB,EAAoC;AAChC,YAAA,QAAQ,GAAG,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAAC,aAAN,EAAhB,CAAX;AACH,WAFD,MAEO;AACH,YAAA,QAAQ,CAAC,IAAT,CAAc,KAAd;AACH;AACJ;AARkB;AAAA;AAAA;AAAA;AAAA;;AASnB,aAAO,QAAP;AACH;;;;;;AAtDL,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FormattedCall = exports.formatEndpoint = void 0;\nconst __1 = require(\"..\");\n/**\n * Creates a FormattedCall from the given endpoint and args.\n */\nfunction formatEndpoint(executingEndpoint, interpretingEndpoint, ...args) {\n    return new FormattedCall(executingEndpoint, interpretingEndpoint, args);\n}\nexports.formatEndpoint = formatEndpoint;\n/**\n * Formats and validates the arguments of a bound call.\n * A bound call is represented by a function and its arguments packed together.\n * A function is defined as something that has an EndpointDefinition and may be:\n * - a smart contract method\n * - a built-in function (such as an ESDT transfer)\n */\nclass FormattedCall {\n    constructor(executingEndpoint, interpretingEndpoint, args) {\n        this.executingEndpoint = executingEndpoint;\n        this.interpretingEndpoint = interpretingEndpoint;\n        this.args = args;\n    }\n    getExecutingFunction() {\n        return new __1.ContractFunction(this.executingEndpoint.name);\n    }\n    getInterpretingFunction() {\n        return new __1.ContractFunction(this.interpretingEndpoint.name);\n    }\n    /**\n     * Takes the given arguments, and converts them to typed values, validating them against the given endpoint in the process.\n     */\n    toTypedValues() {\n        let expandedArgs = this.getExpandedArgs();\n        return __1.NativeSerializer.nativeToTypedValues(expandedArgs, this.executingEndpoint);\n    }\n    toArgBuffers() {\n        let typedValues = this.toTypedValues();\n        return new __1.ArgSerializer().valuesToBuffers(typedValues);\n    }\n    /**\n     * Formats the function name and its arguments as an array of buffers.\n     * This is useful for nested calls (for the multisig smart contract or for ESDT transfers).\n     * A formatted deploy call does not return the function name.\n     */\n    toCallBuffers() {\n        if (this.executingEndpoint.isConstructor()) {\n            return this.toArgBuffers();\n        }\n        return [Buffer.from(this.executingEndpoint.name), ...this.toArgBuffers()];\n    }\n    getExpandedArgs() {\n        let expanded = [];\n        for (let value of this.args) {\n            if (value instanceof FormattedCall) {\n                expanded = expanded.concat(value.toCallBuffers());\n            }\n            else {\n                expanded.push(value);\n            }\n        }\n        return expanded;\n    }\n}\nexports.FormattedCall = FormattedCall;\n//# sourceMappingURL=formattedCall.js.map"]},"metadata":{},"sourceType":"script"}