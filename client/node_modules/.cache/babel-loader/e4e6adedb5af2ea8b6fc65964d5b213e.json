{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayVecBinaryCodec = void 0;\n\nvar typesystem_1 = require(\"../typesystem\");\n\nvar ArrayVecBinaryCodec = /*#__PURE__*/function () {\n  function ArrayVecBinaryCodec(binaryCodec) {\n    _classCallCheck(this, ArrayVecBinaryCodec);\n\n    this.binaryCodec = binaryCodec;\n  }\n\n  _createClass(ArrayVecBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var arrayLength = type.length;\n      var typeParameter = type.getFirstTypeParameter();\n      var result = [];\n      var totalLength = 0;\n\n      for (var i = 0; i < arrayLength; i++) {\n        var _this$binaryCodec$dec = this.binaryCodec.decodeNested(buffer, typeParameter),\n            _this$binaryCodec$dec2 = _slicedToArray(_this$binaryCodec$dec, 2),\n            decoded = _this$binaryCodec$dec2[0],\n            decodedLength = _this$binaryCodec$dec2[1];\n\n        result.push(decoded);\n        totalLength += decodedLength;\n        buffer = buffer.slice(decodedLength);\n      }\n\n      return [new typesystem_1.ArrayVec(type, result), totalLength];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var _this$decodeNested = this.decodeNested(buffer, type),\n          _this$decodeNested2 = _slicedToArray(_this$decodeNested, 2),\n          result = _this$decodeNested2[0],\n          _ = _this$decodeNested2[1];\n\n      return result;\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(array) {\n      var itemsBuffers = [];\n\n      var _iterator = _createForOfIteratorHelper(array.getItems()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          var itemBuffer = this.binaryCodec.encodeNested(item);\n          itemsBuffers.push(itemBuffer);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return Buffer.concat(itemsBuffers);\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(array) {\n      return this.encodeNested(array);\n    }\n  }]);\n\n  return ArrayVecBinaryCodec;\n}();\n\nexports.ArrayVecBinaryCodec = ArrayVecBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/arrayVec.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,IAAA,YAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;IAGa,mB;AAGT,+BAAY,WAAZ,EAAoC;AAAA;;AAChC,SAAK,WAAL,GAAmB,WAAnB;AACH;;;;WAED,sBAAa,MAAb,EAA6B,IAA7B,EAA+C;AAC3C,UAAI,WAAW,GAAG,IAAI,CAAC,MAAvB;AACA,UAAI,aAAa,GAAG,IAAI,CAAC,qBAAL,EAApB;AACA,UAAI,MAAM,GAAiB,EAA3B;AACA,UAAI,WAAW,GAAG,CAAlB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,oCAA+B,KAAK,WAAL,CAAiB,YAAjB,CAA8B,MAA9B,EAAsC,aAAtC,CAA/B;AAAA;AAAA,YAAK,OAAL;AAAA,YAAc,aAAd;;AACA,QAAA,MAAM,CAAC,IAAP,CAAY,OAAZ;AACA,QAAA,WAAW,IAAI,aAAf;AACA,QAAA,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,aAAb,CAAT;AACH;;AAED,aAAO,CAAC,IAAI,YAAA,CAAA,QAAJ,CAAa,IAAb,EAAmB,MAAnB,CAAD,EAA6B,WAA7B,CAAP;AACH;;;WAED,wBAAe,MAAf,EAA+B,IAA/B,EAAiD;AAC7C,+BAAkB,KAAK,YAAL,CAAkB,MAAlB,EAA0B,IAA1B,CAAlB;AAAA;AAAA,UAAK,MAAL;AAAA,UAAa,CAAb;;AACA,aAAO,MAAP;AACH;;;WAED,sBAAa,KAAb,EAA4B;AACxB,UAAI,YAAY,GAAa,EAA7B;;AADwB,iDAGL,KAAK,CAAC,QAAN,EAHK;AAAA;;AAAA;AAGxB,4DAAqC;AAAA,cAA1B,IAA0B;AACjC,cAAI,UAAU,GAAG,KAAK,WAAL,CAAiB,YAAjB,CAA8B,IAA9B,CAAjB;AACA,UAAA,YAAY,CAAC,IAAb,CAAkB,UAAlB;AACH;AANuB;AAAA;AAAA;AAAA;AAAA;;AAQxB,aAAO,MAAM,CAAC,MAAP,CAAc,YAAd,CAAP;AACH;;;WAED,wBAAe,KAAf,EAA8B;AAC1B,aAAO,KAAK,YAAL,CAAkB,KAAlB,CAAP;AACH;;;;;;AAzCL,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArrayVecBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nclass ArrayVecBinaryCodec {\n    constructor(binaryCodec) {\n        this.binaryCodec = binaryCodec;\n    }\n    decodeNested(buffer, type) {\n        let arrayLength = type.length;\n        let typeParameter = type.getFirstTypeParameter();\n        let result = [];\n        let totalLength = 0;\n        for (let i = 0; i < arrayLength; i++) {\n            let [decoded, decodedLength] = this.binaryCodec.decodeNested(buffer, typeParameter);\n            result.push(decoded);\n            totalLength += decodedLength;\n            buffer = buffer.slice(decodedLength);\n        }\n        return [new typesystem_1.ArrayVec(type, result), totalLength];\n    }\n    decodeTopLevel(buffer, type) {\n        let [result, _] = this.decodeNested(buffer, type);\n        return result;\n    }\n    encodeNested(array) {\n        let itemsBuffers = [];\n        for (const item of array.getItems()) {\n            let itemBuffer = this.binaryCodec.encodeNested(item);\n            itemsBuffers.push(itemBuffer);\n        }\n        return Buffer.concat(itemsBuffers);\n    }\n    encodeTopLevel(array) {\n        return this.encodeNested(array);\n    }\n}\nexports.ArrayVecBinaryCodec = ArrayVecBinaryCodec;\n//# sourceMappingURL=arrayVec.js.map"]},"metadata":{},"sourceType":"script"}