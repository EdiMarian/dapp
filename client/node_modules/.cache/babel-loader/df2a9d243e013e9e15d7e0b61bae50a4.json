{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interaction = void 0;\n\nvar balance_1 = require(\"../balance\");\n\nvar networkParams_1 = require(\"../networkParams\");\n\nvar query_1 = require(\"./query\");\n\nvar address_1 = require(\"../address\");\n\nvar nonce_1 = require(\"../nonce\");\n/**\n * Interactions can be seen as mutable transaction & query builders.\n *\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\n * the execution outcome for the objects they've built.\n */\n\n\nvar Interaction = /*#__PURE__*/function () {\n  function Interaction(contract, executingFunction, interpretingFunction, args, receiver) {\n    _classCallCheck(this, Interaction);\n\n    this.nonce = new nonce_1.Nonce(0);\n    this.value = balance_1.Balance.Zero();\n    this.gasLimit = networkParams_1.GasLimit.min();\n    this.contract = contract;\n    this.executingFunction = executingFunction;\n    this.interpretingFunction = interpretingFunction;\n    this.args = args;\n    this.receiver = receiver;\n  }\n\n  _createClass(Interaction, [{\n    key: \"getContract\",\n    value: function getContract() {\n      return this.contract;\n    }\n  }, {\n    key: \"getInterpretingFunction\",\n    value: function getInterpretingFunction() {\n      return this.interpretingFunction;\n    }\n  }, {\n    key: \"getExecutingFunction\",\n    value: function getExecutingFunction() {\n      return this.executingFunction;\n    }\n  }, {\n    key: \"getArguments\",\n    value: function getArguments() {\n      return this.args;\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.value;\n    }\n  }, {\n    key: \"getGasLimit\",\n    value: function getGasLimit() {\n      return this.gasLimit;\n    }\n  }, {\n    key: \"buildTransaction\",\n    value: function buildTransaction() {\n      // TODO: create as \"deploy\" transaction if the function is \"init\" (or find a better pattern for deployments).\n      var transaction = this.contract.call({\n        func: this.executingFunction,\n        // GasLimit will be set using \"withGasLimit()\".\n        gasLimit: this.gasLimit,\n        args: this.args,\n        // Value will be set using \"withValue()\".\n        value: this.value,\n        receiver: this.receiver\n      });\n      transaction.setNonce(this.nonce);\n      return transaction;\n    }\n  }, {\n    key: \"buildQuery\",\n    value: function buildQuery() {\n      return new query_1.Query({\n        address: this.contract.getAddress(),\n        func: this.executingFunction,\n        args: this.args,\n        // Value will be set using \"withValue()\".\n        value: this.value,\n        // Caller will be set by the InteractionRunner.\n        caller: new address_1.Address()\n      });\n    }\n    /**\n     * Interprets the results of a previously broadcasted (and fully executed) smart contract transaction.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n\n  }, {\n    key: \"interpretExecutionResults\",\n    value: function interpretExecutionResults(transactionOnNetwork) {\n      return _interpretExecutionResults(this.getEndpoint(), transactionOnNetwork);\n    }\n    /**\n     * Interprets the raw outcome of a Smart Contract query.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n\n  }, {\n    key: \"interpretQueryResponse\",\n    value: function interpretQueryResponse(queryResponse) {\n      var endpoint = this.getEndpoint();\n      queryResponse.setEndpointDefinition(endpoint);\n      var values = queryResponse.outputTyped();\n      var returnCode = queryResponse.returnCode;\n      return {\n        queryResponse: queryResponse,\n        values: values,\n        firstValue: values[0],\n        returnCode: returnCode\n      };\n    }\n  }, {\n    key: \"withValue\",\n    value: function withValue(value) {\n      this.value = value;\n      return this;\n    }\n  }, {\n    key: \"withGasLimit\",\n    value: function withGasLimit(gasLimit) {\n      this.gasLimit = gasLimit;\n      return this;\n    }\n  }, {\n    key: \"withNonce\",\n    value: function withNonce(nonce) {\n      this.nonce = nonce;\n      return this;\n    }\n  }, {\n    key: \"getEndpoint\",\n    value: function getEndpoint() {\n      return this.getContract().getAbi().getEndpoint(this.getInterpretingFunction());\n    }\n  }]);\n\n  return Interaction;\n}();\n\nexports.Interaction = Interaction;\n\nfunction _interpretExecutionResults(endpoint, transactionOnNetwork) {\n  var smartContractResults = transactionOnNetwork.getSmartContractResults();\n  var immediateResult = smartContractResults.getImmediate();\n  var resultingCalls = smartContractResults.getResultingCalls();\n  immediateResult.setEndpointDefinition(endpoint);\n  var values = immediateResult.outputTyped();\n  var returnCode = immediateResult.getReturnCode();\n  return {\n    transactionOnNetwork: transactionOnNetwork,\n    smartContractResults: smartContractResults,\n    immediateResult: immediateResult,\n    resultingCalls: resultingCalls,\n    values: values,\n    firstValue: values[0],\n    returnCode: returnCode\n  };\n}","map":{"version":3,"sources":["../../src/smartcontracts/interaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Interaction = void 0;\nconst balance_1 = require(\"../balance\");\nconst networkParams_1 = require(\"../networkParams\");\nconst query_1 = require(\"./query\");\nconst address_1 = require(\"../address\");\nconst nonce_1 = require(\"../nonce\");\n/**\n * Interactions can be seen as mutable transaction & query builders.\n *\n * Aside from building transactions and queries, the interactors are also responsible for interpreting\n * the execution outcome for the objects they've built.\n */\nclass Interaction {\n    constructor(contract, executingFunction, interpretingFunction, args, receiver) {\n        this.nonce = new nonce_1.Nonce(0);\n        this.value = balance_1.Balance.Zero();\n        this.gasLimit = networkParams_1.GasLimit.min();\n        this.contract = contract;\n        this.executingFunction = executingFunction;\n        this.interpretingFunction = interpretingFunction;\n        this.args = args;\n        this.receiver = receiver;\n    }\n    getContract() {\n        return this.contract;\n    }\n    getInterpretingFunction() {\n        return this.interpretingFunction;\n    }\n    getExecutingFunction() {\n        return this.executingFunction;\n    }\n    getArguments() {\n        return this.args;\n    }\n    getValue() {\n        return this.value;\n    }\n    getGasLimit() {\n        return this.gasLimit;\n    }\n    buildTransaction() {\n        // TODO: create as \"deploy\" transaction if the function is \"init\" (or find a better pattern for deployments).\n        let transaction = this.contract.call({\n            func: this.executingFunction,\n            // GasLimit will be set using \"withGasLimit()\".\n            gasLimit: this.gasLimit,\n            args: this.args,\n            // Value will be set using \"withValue()\".\n            value: this.value,\n            receiver: this.receiver,\n        });\n        transaction.setNonce(this.nonce);\n        return transaction;\n    }\n    buildQuery() {\n        return new query_1.Query({\n            address: this.contract.getAddress(),\n            func: this.executingFunction,\n            args: this.args,\n            // Value will be set using \"withValue()\".\n            value: this.value,\n            // Caller will be set by the InteractionRunner.\n            caller: new address_1.Address()\n        });\n    }\n    /**\n     * Interprets the results of a previously broadcasted (and fully executed) smart contract transaction.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n    interpretExecutionResults(transactionOnNetwork) {\n        return interpretExecutionResults(this.getEndpoint(), transactionOnNetwork);\n    }\n    /**\n     * Interprets the raw outcome of a Smart Contract query.\n     * The outcome is structured such that it allows quick access to each level of detail.\n     */\n    interpretQueryResponse(queryResponse) {\n        let endpoint = this.getEndpoint();\n        queryResponse.setEndpointDefinition(endpoint);\n        let values = queryResponse.outputTyped();\n        let returnCode = queryResponse.returnCode;\n        return {\n            queryResponse: queryResponse,\n            values: values,\n            firstValue: values[0],\n            returnCode: returnCode\n        };\n    }\n    withValue(value) {\n        this.value = value;\n        return this;\n    }\n    withGasLimit(gasLimit) {\n        this.gasLimit = gasLimit;\n        return this;\n    }\n    withNonce(nonce) {\n        this.nonce = nonce;\n        return this;\n    }\n    getEndpoint() {\n        return this.getContract().getAbi().getEndpoint(this.getInterpretingFunction());\n    }\n}\nexports.Interaction = Interaction;\nfunction interpretExecutionResults(endpoint, transactionOnNetwork) {\n    let smartContractResults = transactionOnNetwork.getSmartContractResults();\n    let immediateResult = smartContractResults.getImmediate();\n    let resultingCalls = smartContractResults.getResultingCalls();\n    immediateResult.setEndpointDefinition(endpoint);\n    let values = immediateResult.outputTyped();\n    let returnCode = immediateResult.getReturnCode();\n    return {\n        transactionOnNetwork: transactionOnNetwork,\n        smartContractResults: smartContractResults,\n        immediateResult,\n        resultingCalls,\n        values,\n        firstValue: values[0],\n        returnCode: returnCode\n    };\n}\n//# sourceMappingURL=interaction.js.map"]},"metadata":{},"sourceType":"script"}