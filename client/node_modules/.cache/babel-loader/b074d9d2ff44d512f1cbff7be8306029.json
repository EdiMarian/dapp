{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionWatcher = void 0;\n\nvar asyncTimer_1 = require(\"./asyncTimer\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar logger_1 = require(\"./logger\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\n\n\nvar TransactionWatcher = /*#__PURE__*/function () {\n  /**\n   *\n   * @param hash The hash of the transaction to watch\n   * @param fetcher The transaction fetcher\n   * @param pollingInterval The polling interval, in milliseconds\n   * @param timeout The timeout, in milliseconds\n   */\n  function TransactionWatcher(hash, fetcher) {\n    var pollingInterval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TransactionWatcher.DefaultPollingInterval;\n    var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TransactionWatcher.DefaultTimeout;\n\n    _classCallCheck(this, TransactionWatcher);\n\n    this.hash = hash;\n    this.fetcher = fetcher;\n    this.pollingInterval = pollingInterval;\n    this.timeout = timeout;\n  }\n  /**\n   * Waits until the transaction reaches the \"pending\" status.\n   */\n\n\n  _createClass(TransactionWatcher, [{\n    key: \"awaitPending\",\n    value: function awaitPending(onStatusReceived) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.awaitStatus(function (status) {\n                  return status.isPending();\n                }, onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n      * Waits until the transaction reaches the \"executed\" status.\n      */\n\n  }, {\n    key: \"awaitExecuted\",\n    value: function awaitExecuted(onStatusReceived) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.awaitStatus(function (status) {\n                  return status.isExecuted();\n                }, onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Waits until the predicate over the transaction status evaluates to \"true\".\n     * @param isAwaitedStatus A predicate over the status\n     */\n\n  }, {\n    key: \"awaitStatus\",\n    value: function awaitStatus(isAwaitedStatus, onStatusReceived) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this = this;\n\n        var doFetch, errorProvider;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                doFetch = function doFetch() {\n                  return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return this.fetcher.getTransactionStatus(this.hash);\n\n                          case 2:\n                            return _context3.abrupt(\"return\", _context3.sent);\n\n                          case 3:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3, this);\n                  }));\n                };\n\n                errorProvider = function errorProvider() {\n                  return new errors.ErrExpectedTransactionStatusNotReached();\n                };\n\n                return _context4.abrupt(\"return\", this.awaitConditionally(isAwaitedStatus, doFetch, onStatusReceived, errorProvider));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"awaitNotarized\",\n    value: function awaitNotarized() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this2 = this;\n\n        var isNotarized, doFetch, errorProvider;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                isNotarized = function isNotarized(data) {\n                  return !data.hyperblockHash.isEmpty();\n                };\n\n                doFetch = function doFetch() {\n                  return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return this.fetcher.getTransaction(this.hash);\n\n                          case 2:\n                            return _context5.abrupt(\"return\", _context5.sent);\n\n                          case 3:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5, this);\n                  }));\n                };\n\n                errorProvider = function errorProvider() {\n                  return new errors.ErrTransactionWatcherTimeout();\n                };\n\n                return _context6.abrupt(\"return\", this.awaitConditionally(isNotarized, doFetch, function (_) {}, errorProvider));\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"awaitConditionally\",\n    value: function awaitConditionally(isSatisfied, doFetch, onFetched, createError) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var periodicTimer, timeoutTimer, stop, fetchedData, _, notSatisfied, error;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n                timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n                stop = false;\n                fetchedData = undefined;\n                _ = timeoutTimer.start(this.timeout).finally(function () {\n                  timeoutTimer.stop();\n                  stop = true;\n                });\n\n              case 5:\n                if (stop) {\n                  _context7.next = 24;\n                  break;\n                }\n\n                _context7.prev = 6;\n                _context7.next = 9;\n                return doFetch();\n\n              case 9:\n                fetchedData = _context7.sent;\n\n                if (onFetched) {\n                  onFetched(fetchedData);\n                }\n\n                if (!(isSatisfied(fetchedData) || stop)) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                return _context7.abrupt(\"break\", 24);\n\n              case 13:\n                _context7.next = 20;\n                break;\n\n              case 15:\n                _context7.prev = 15;\n                _context7.t0 = _context7[\"catch\"](6);\n\n                if (_context7.t0 instanceof errors.Err) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                throw _context7.t0;\n\n              case 19:\n                logger_1.Logger.info(\"cannot (yet) fetch data\");\n\n              case 20:\n                _context7.next = 22;\n                return periodicTimer.start(this.pollingInterval);\n\n              case 22:\n                _context7.next = 5;\n                break;\n\n              case 24:\n                if (!timeoutTimer.isStopped()) {\n                  timeoutTimer.stop();\n                }\n\n                notSatisfied = !fetchedData || !isSatisfied(fetchedData);\n\n                if (!notSatisfied) {\n                  _context7.next = 29;\n                  break;\n                }\n\n                error = createError();\n                throw error;\n\n              case 29:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[6, 15]]);\n      }));\n    }\n  }]);\n\n  return TransactionWatcher;\n}();\n\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\n\nTransactionWatcher.NoopOnStatusReceived = function (_) {};","map":{"version":3,"sources":["../src/transactionWatcher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionWatcher = void 0;\nconst asyncTimer_1 = require(\"./asyncTimer\");\nconst errors = __importStar(require(\"./errors\"));\nconst logger_1 = require(\"./logger\");\n/**\n * TransactionWatcher allows one to continuously watch (monitor), by means of polling, the status of a given transaction.\n */\nclass TransactionWatcher {\n    /**\n     *\n     * @param hash The hash of the transaction to watch\n     * @param fetcher The transaction fetcher\n     * @param pollingInterval The polling interval, in milliseconds\n     * @param timeout The timeout, in milliseconds\n     */\n    constructor(hash, fetcher, pollingInterval = TransactionWatcher.DefaultPollingInterval, timeout = TransactionWatcher.DefaultTimeout) {\n        this.hash = hash;\n        this.fetcher = fetcher;\n        this.pollingInterval = pollingInterval;\n        this.timeout = timeout;\n    }\n    /**\n     * Waits until the transaction reaches the \"pending\" status.\n     */\n    awaitPending(onStatusReceived) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.awaitStatus(status => status.isPending(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n        });\n    }\n    /**\n      * Waits until the transaction reaches the \"executed\" status.\n      */\n    awaitExecuted(onStatusReceived) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.awaitStatus(status => status.isExecuted(), onStatusReceived || TransactionWatcher.NoopOnStatusReceived);\n        });\n    }\n    /**\n     * Waits until the predicate over the transaction status evaluates to \"true\".\n     * @param isAwaitedStatus A predicate over the status\n     */\n    awaitStatus(isAwaitedStatus, onStatusReceived) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransactionStatus(this.hash); });\n            let errorProvider = () => new errors.ErrExpectedTransactionStatusNotReached();\n            return this.awaitConditionally(isAwaitedStatus, doFetch, onStatusReceived, errorProvider);\n        });\n    }\n    awaitNotarized() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let isNotarized = (data) => !data.hyperblockHash.isEmpty();\n            let doFetch = () => __awaiter(this, void 0, void 0, function* () { return yield this.fetcher.getTransaction(this.hash); });\n            let errorProvider = () => new errors.ErrTransactionWatcherTimeout();\n            return this.awaitConditionally(isNotarized, doFetch, (_) => { }, errorProvider);\n        });\n    }\n    awaitConditionally(isSatisfied, doFetch, onFetched, createError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let periodicTimer = new asyncTimer_1.AsyncTimer(\"watcher:periodic\");\n            let timeoutTimer = new asyncTimer_1.AsyncTimer(\"watcher:timeout\");\n            let stop = false;\n            let fetchedData = undefined;\n            let _ = timeoutTimer.start(this.timeout).finally(() => {\n                timeoutTimer.stop();\n                stop = true;\n            });\n            while (!stop) {\n                try {\n                    fetchedData = yield doFetch();\n                    if (onFetched) {\n                        onFetched(fetchedData);\n                    }\n                    if (isSatisfied(fetchedData) || stop) {\n                        break;\n                    }\n                }\n                catch (error) {\n                    if (!(error instanceof errors.Err)) {\n                        throw error;\n                    }\n                    logger_1.Logger.info(\"cannot (yet) fetch data\");\n                }\n                yield periodicTimer.start(this.pollingInterval);\n            }\n            if (!timeoutTimer.isStopped()) {\n                timeoutTimer.stop();\n            }\n            let notSatisfied = !fetchedData || !isSatisfied(fetchedData);\n            if (notSatisfied) {\n                let error = createError();\n                throw error;\n            }\n        });\n    }\n}\nexports.TransactionWatcher = TransactionWatcher;\nTransactionWatcher.DefaultPollingInterval = 6000;\nTransactionWatcher.DefaultTimeout = TransactionWatcher.DefaultPollingInterval * 15;\nTransactionWatcher.NoopOnStatusReceived = (_) => { };\n//# sourceMappingURL=transactionWatcher.js.map"]},"metadata":{},"sourceType":"script"}