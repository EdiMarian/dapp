{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\n\nvar utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\n\n\nvar Type = /*#__PURE__*/function () {\n  function Type(name) {\n    var typeParameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var cardinality = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TypeCardinality.fixed(1);\n\n    _classCallCheck(this, Type);\n\n    utils_1.guardValueIsSet(\"name\", name);\n    this.name = name;\n    this.typeParameters = typeParameters;\n    this.cardinality = cardinality;\n  }\n\n  _createClass(Type, [{\n    key: \"getName\",\n    value: function getName() {\n      return this.name;\n    }\n  }, {\n    key: \"getTypeParameters\",\n    value: function getTypeParameters() {\n      return this.typeParameters;\n    }\n  }, {\n    key: \"isGenericType\",\n    value: function isGenericType() {\n      return this.typeParameters.length > 0;\n    }\n  }, {\n    key: \"getFirstTypeParameter\",\n    value: function getFirstTypeParameter() {\n      utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n      return this.typeParameters[0];\n    }\n    /**\n     * Generates type expressions similar to elrond-wasm-rs.\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var typeParameters = this.getTypeParameters().map(function (type) {\n        return type.toString();\n      }).join(\", \");\n      var typeParametersExpression = typeParameters ? \"<\".concat(typeParameters, \">\") : \"\";\n      return \"\".concat(this.name).concat(typeParametersExpression);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return Type.equals(this, other);\n    }\n  }, {\n    key: \"differs\",\n    value: function differs(other) {\n      return !this.equals(other);\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.name;\n    }\n    /**\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n     *\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n     * For example, Option<u32> is assignable from Option<?>.\n     * For more details, see the implementation of {@link OptionType}.\n     *\n     * Also see:\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n     */\n\n  }, {\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      var invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), type.getTypeParameters());\n      return type instanceof this.constructor && invariantTypeParameters;\n    }\n    /**\n     * Converts the account to a pretty, plain JavaScript object.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        name: this.name,\n        typeParameters: this.typeParameters.map(function (item) {\n          return item.toJSON();\n        })\n      };\n    }\n  }, {\n    key: \"getCardinality\",\n    value: function getCardinality() {\n      return this.cardinality;\n    }\n  }], [{\n    key: \"equals\",\n    value: function equals(a, b) {\n      // Workaround that seems to always work properly. Most probable reasons: \n      // - ES6 is quite strict about enumerating over the properties on an object.\n      // - toJSON() returns an object literal (most probably, this results in deterministic iteration in all browser implementations).\n      var aJson = JSON.stringify(a.toJSON());\n      var bJson = JSON.stringify(b.toJSON());\n      return aJson == bJson;\n    }\n  }, {\n    key: \"equalsMany\",\n    value: function equalsMany(a, b) {\n      return a.every(function (type, i) {\n        return type.equals(b[i]);\n      });\n    }\n  }, {\n    key: \"isAssignableFromMany\",\n    value: function isAssignableFromMany(a, b) {\n      return a.every(function (type, i) {\n        return type.isAssignableFrom(b[i]);\n      });\n    }\n  }]);\n\n  return Type;\n}();\n\nexports.Type = Type;\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\n\nvar TypeCardinality = /*#__PURE__*/function () {\n  function TypeCardinality(lowerBound, upperBound) {\n    _classCallCheck(this, TypeCardinality);\n\n    this.lowerBound = lowerBound;\n    this.upperBound = upperBound;\n  }\n\n  _createClass(TypeCardinality, [{\n    key: \"isSingular\",\n    value: function isSingular() {\n      return this.lowerBound == 1 && this.upperBound == 1;\n    }\n  }, {\n    key: \"isSingularOrNone\",\n    value: function isSingularOrNone() {\n      return this.lowerBound == 0 && this.upperBound == 1;\n    }\n  }, {\n    key: \"isComposite\",\n    value: function isComposite() {\n      return this.upperBound != 1;\n    }\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.lowerBound == this.upperBound;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.lowerBound;\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      return this.upperBound || TypeCardinality.MaxCardinality;\n    }\n  }], [{\n    key: \"fixed\",\n    value: function fixed(value) {\n      return new TypeCardinality(value, value);\n    }\n  }, {\n    key: \"variable\",\n    value: function variable(value) {\n      return new TypeCardinality(0, value);\n    }\n  }]);\n\n  return TypeCardinality;\n}();\n\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\n\nTypeCardinality.MaxCardinality = 4096;\n\nvar PrimitiveType = /*#__PURE__*/function (_Type) {\n  _inherits(PrimitiveType, _Type);\n\n  var _super = _createSuper(PrimitiveType);\n\n  function PrimitiveType(name) {\n    _classCallCheck(this, PrimitiveType);\n\n    return _super.call(this, name);\n  }\n\n  return PrimitiveType;\n}(Type);\n\nexports.PrimitiveType = PrimitiveType;\n\nvar CustomType = /*#__PURE__*/function (_Type2) {\n  _inherits(CustomType, _Type2);\n\n  var _super2 = _createSuper(CustomType);\n\n  function CustomType() {\n    _classCallCheck(this, CustomType);\n\n    return _super2.apply(this, arguments);\n  }\n\n  return CustomType;\n}(Type);\n\nexports.CustomType = CustomType;\n\nvar TypedValue = /*#__PURE__*/function () {\n  function TypedValue(type) {\n    _classCallCheck(this, TypedValue);\n\n    this.type = type;\n  }\n\n  _createClass(TypedValue, [{\n    key: \"getType\",\n    value: function getType() {\n      return this.type;\n    }\n  }]);\n\n  return TypedValue;\n}();\n\nexports.TypedValue = TypedValue;\n\nvar PrimitiveValue = /*#__PURE__*/function (_TypedValue) {\n  _inherits(PrimitiveValue, _TypedValue);\n\n  var _super3 = _createSuper(PrimitiveValue);\n\n  function PrimitiveValue(type) {\n    _classCallCheck(this, PrimitiveValue);\n\n    return _super3.call(this, type);\n  }\n\n  return PrimitiveValue;\n}(TypedValue);\n\nexports.PrimitiveValue = PrimitiveValue;\n\nfunction isTyped(value) {\n  return value instanceof TypedValue;\n}\n\nexports.isTyped = isTyped;\n\nvar TypePlaceholder = /*#__PURE__*/function (_Type3) {\n  _inherits(TypePlaceholder, _Type3);\n\n  var _super4 = _createSuper(TypePlaceholder);\n\n  function TypePlaceholder() {\n    _classCallCheck(this, TypePlaceholder);\n\n    return _super4.call(this, \"...\");\n  }\n\n  return TypePlaceholder;\n}(Type);\n\nexports.TypePlaceholder = TypePlaceholder;\n\nvar NullType = /*#__PURE__*/function (_Type4) {\n  _inherits(NullType, _Type4);\n\n  var _super5 = _createSuper(NullType);\n\n  function NullType() {\n    _classCallCheck(this, NullType);\n\n    return _super5.call(this, \"?\");\n  }\n\n  return NullType;\n}(Type);\n\nexports.NullType = NullType;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/types.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;AAGG;;;IACU,I;AAKT,gBAAmB,IAAnB,EAAqH;AAAA,QAApF,cAAoF,uEAA3D,EAA2D;AAAA,QAAvD,WAAuD,uEAAxB,eAAe,CAAC,KAAhB,CAAsB,CAAtB,CAAwB;;AAAA;;AACjH,IAAA,OAAA,CAAA,eAAA,CAAgB,MAAhB,EAAwB,IAAxB;AAEA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,cAAL,GAAsB,cAAtB;AACA,SAAK,WAAL,GAAmB,WAAnB;AACH;;;;WAED,mBAAO;AACH,aAAO,KAAK,IAAZ;AACH;;;WAED,6BAAiB;AACb,aAAO,KAAK,cAAZ;AACH;;;WAED,yBAAa;AACT,aAAO,KAAK,cAAL,CAAoB,MAApB,GAA6B,CAApC;AACH;;;WAED,iCAAqB;AACjB,MAAA,OAAA,CAAA,SAAA,CAAU,KAAK,cAAL,CAAoB,MAApB,GAA6B,CAAvC,EAA0C,4BAA1C;AACA,aAAO,KAAK,cAAL,CAAoB,CAApB,CAAP;AACH;AAGD;;AAEG;;;;WACH,oBAAQ;AACJ,UAAI,cAAc,GAAW,KAAK,iBAAL,GAAyB,GAAzB,CAA6B,UAAA,IAAI;AAAA,eAAI,IAAI,CAAC,QAAL,EAAJ;AAAA,OAAjC,EAAsD,IAAtD,CAA2D,IAA3D,CAA7B;AACA,UAAI,wBAAwB,GAAG,cAAc,cAAO,cAAP,SAA2B,EAAxE;AACA,uBAAU,KAAK,IAAf,SAAsB,wBAAtB;AACH;;;WAED,gBAAO,KAAP,EAAkB;AACd,aAAO,IAAI,CAAC,MAAL,CAAY,IAAZ,EAAkB,KAAlB,CAAP;AACH;;;WAoBD,iBAAQ,KAAR,EAAmB;AACf,aAAO,CAAC,KAAK,MAAL,CAAY,KAAZ,CAAR;AACH;;;WAED,mBAAO;AACH,aAAO,KAAK,IAAZ;AACH;AAED;;;;;;;;;;;AAWG;;;;WACH,0BAAiB,IAAjB,EAA2B;AACvB,UAAI,uBAAuB,GAAG,IAAI,CAAC,UAAL,CAAgB,KAAK,iBAAL,EAAhB,EAA0C,IAAI,CAAC,iBAAL,EAA1C,CAA9B;AACA,aAAO,IAAI,YAAY,KAAK,WAArB,IAAoC,uBAA3C;AACH;AAED;;AAEG;;;;WACH,kBAAM;AACF,aAAO;AACH,QAAA,IAAI,EAAE,KAAK,IADR;AAEH,QAAA,cAAc,EAAE,KAAK,cAAL,CAAoB,GAApB,CAAwB,UAAA,IAAI;AAAA,iBAAI,IAAI,CAAC,MAAL,EAAJ;AAAA,SAA5B;AAFb,OAAP;AAIH;;;WAED,0BAAc;AACV,aAAO,KAAK,WAAZ;AACH;;;WAvDD,gBAAc,CAAd,EAAuB,CAAvB,EAA8B;AAC1B;AACA;AACA;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,CAAC,CAAC,MAAF,EAAf,CAAZ;AACA,UAAI,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,CAAC,CAAC,MAAF,EAAf,CAAZ;AAEA,aAAO,KAAK,IAAI,KAAhB;AACH;;;WAED,oBAAkB,CAAlB,EAA6B,CAA7B,EAAsC;AAClC,aAAO,CAAC,CAAC,KAAF,CAAQ,UAAC,IAAD,EAAa,CAAb;AAAA,eAA2B,IAAI,CAAC,MAAL,CAAY,CAAC,CAAC,CAAD,CAAb,CAA3B;AAAA,OAAR,CAAP;AACH;;;WAED,8BAA4B,CAA5B,EAAuC,CAAvC,EAAgD;AAC5C,aAAO,CAAC,CAAC,KAAF,CAAQ,UAAC,IAAD,EAAa,CAAb;AAAA,eAA2B,IAAI,CAAC,gBAAL,CAAsB,CAAC,CAAC,CAAD,CAAvB,CAA3B;AAAA,OAAR,CAAP;AACH;;;;;;AA5DL,OAAA,CAAA,IAAA,GAAA,IAAA;AAsGA;;;;;;;;;AASG;;IACU,e;AAST,2BAAoB,UAApB,EAAwC,UAAxC,EAA2D;AAAA;;AACvD,SAAK,UAAL,GAAkB,UAAlB;AACA,SAAK,UAAL,GAAkB,UAAlB;AACH;;;;WAUD,sBAAU;AACN,aAAO,KAAK,UAAL,IAAmB,CAAnB,IAAwB,KAAK,UAAL,IAAmB,CAAlD;AACH;;;WAED,4BAAgB;AACZ,aAAO,KAAK,UAAL,IAAmB,CAAnB,IAAwB,KAAK,UAAL,IAAmB,CAAlD;AACH;;;WAED,uBAAW;AACP,aAAO,KAAK,UAAL,IAAmB,CAA1B;AACH;;;WAED,mBAAO;AACH,aAAO,KAAK,UAAL,IAAmB,KAAK,UAA/B;AACH;;;WAED,yBAAa;AACT,aAAO,KAAK,UAAZ;AACH;;;WAED,yBAAa;AACT,aAAO,KAAK,UAAL,IAAmB,eAAe,CAAC,cAA1C;AACH;;;WA9BD,eAAa,KAAb,EAA0B;AACtB,aAAO,IAAI,eAAJ,CAAoB,KAApB,EAA2B,KAA3B,CAAP;AACH;;;WAED,kBAAgB,KAAhB,EAA8B;AAC1B,aAAO,IAAI,eAAJ,CAAoB,CAApB,EAAuB,KAAvB,CAAP;AACH;;;;;;AApBL,OAAA,CAAA,eAAA,GAAA,eAAA;AACI;;AAEG;;AACY,eAAA,CAAA,cAAA,GAAyB,IAAzB;;IA2CN,a;;;;;AACT,yBAAY,IAAZ,EAAwB;AAAA;;AAAA,6BACd,IADc;AAEvB;;;EAH8B,I;;AAAnC,OAAA,CAAA,aAAA,GAAA,aAAA;;IAMsB,U;;;;;;;;;;;;EAAmB,I;;AAAzC,OAAA,CAAA,UAAA,GAAA,UAAA;;IAGsB,U;AAGlB,sBAAY,IAAZ,EAAsB;AAAA;;AAClB,SAAK,IAAL,GAAY,IAAZ;AACH;;;;WAED,mBAAO;AACH,aAAO,KAAK,IAAZ;AACH;;;;;;AATL,OAAA,CAAA,UAAA,GAAA,UAAA;;IAesB,c;;;;;AAClB,0BAAY,IAAZ,EAAsB;AAAA;;AAAA,8BACZ,IADY;AAErB;;;EAHwC,U;;AAA7C,OAAA,CAAA,cAAA,GAAA,cAAA;;AAMA,SAAgB,OAAhB,CAAwB,KAAxB,EAAkC;AAC9B,SAAO,KAAK,YAAY,UAAxB;AACH;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA;;IAIa,e;;;;;AACT,6BAAA;AAAA;;AAAA,8BACU,KADV;AAEC;;;EAHgC,I;;AAArC,OAAA,CAAA,eAAA,GAAA,eAAA;;IAOa,Q;;;;;AACT,sBAAA;AAAA;;AAAA,8BACU,GADV;AAEC;;;EAHyB,I;;AAA9B,OAAA,CAAA,QAAA,GAAA,QAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NullType = exports.TypePlaceholder = exports.isTyped = exports.PrimitiveValue = exports.TypedValue = exports.CustomType = exports.PrimitiveType = exports.TypeCardinality = exports.Type = void 0;\nconst utils_1 = require(\"../../utils\");\n/**\n * An abstraction that represents a Type. Handles both generic and non-generic types.\n * Once instantiated as a Type, a generic type is \"closed\" (as opposed to \"open\").\n */\nclass Type {\n    constructor(name, typeParameters = [], cardinality = TypeCardinality.fixed(1)) {\n        utils_1.guardValueIsSet(\"name\", name);\n        this.name = name;\n        this.typeParameters = typeParameters;\n        this.cardinality = cardinality;\n    }\n    getName() {\n        return this.name;\n    }\n    getTypeParameters() {\n        return this.typeParameters;\n    }\n    isGenericType() {\n        return this.typeParameters.length > 0;\n    }\n    getFirstTypeParameter() {\n        utils_1.guardTrue(this.typeParameters.length > 0, \"type parameters length > 0\");\n        return this.typeParameters[0];\n    }\n    /**\n     * Generates type expressions similar to elrond-wasm-rs.\n     */\n    toString() {\n        let typeParameters = this.getTypeParameters().map(type => type.toString()).join(\", \");\n        let typeParametersExpression = typeParameters ? `<${typeParameters}>` : \"\";\n        return `${this.name}${typeParametersExpression}`;\n    }\n    equals(other) {\n        return Type.equals(this, other);\n    }\n    static equals(a, b) {\n        // Workaround that seems to always work properly. Most probable reasons: \n        // - ES6 is quite strict about enumerating over the properties on an object.\n        // - toJSON() returns an object literal (most probably, this results in deterministic iteration in all browser implementations).\n        let aJson = JSON.stringify(a.toJSON());\n        let bJson = JSON.stringify(b.toJSON());\n        return aJson == bJson;\n    }\n    static equalsMany(a, b) {\n        return a.every((type, i) => type.equals(b[i]));\n    }\n    static isAssignableFromMany(a, b) {\n        return a.every((type, i) => type.isAssignableFrom(b[i]));\n    }\n    differs(other) {\n        return !this.equals(other);\n    }\n    valueOf() {\n        return this.name;\n    }\n    /**\n     * Inspired from: https://docs.microsoft.com/en-us/dotnet/api/system.type.isassignablefrom\n     * For (most) generics, type invariance is expected (assumed) - neither covariance, nor contravariance are supported yet (will be supported in a next release).\n     *\n     * One exception though: for {@link OptionType}, we simulate covariance for missing (not provided) values.\n     * For example, Option<u32> is assignable from Option<?>.\n     * For more details, see the implementation of {@link OptionType}.\n     *\n     * Also see:\n     *  - https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\n     *  - https://docs.microsoft.com/en-us/dotnet/standard/generics/covariance-and-contravariance\n     */\n    isAssignableFrom(type) {\n        let invariantTypeParameters = Type.equalsMany(this.getTypeParameters(), type.getTypeParameters());\n        return type instanceof this.constructor && invariantTypeParameters;\n    }\n    /**\n     * Converts the account to a pretty, plain JavaScript object.\n     */\n    toJSON() {\n        return {\n            name: this.name,\n            typeParameters: this.typeParameters.map(item => item.toJSON())\n        };\n    }\n    getCardinality() {\n        return this.cardinality;\n    }\n}\nexports.Type = Type;\n/**\n * TODO: Simplify this class, keep only what is needed.\n *\n * An abstraction for defining and operating with the cardinality of a (composite or simple) type.\n *\n * Simple types (the ones that are directly encodable) have a fixed cardinality: [lower = 1, upper = 1].\n * Composite types (not directly encodable) do not follow this constraint. For example:\n *  - VarArgs: [lower = 0, upper = *]\n *  - OptionalResult: [lower = 0, upper = 1]\n */\nclass TypeCardinality {\n    constructor(lowerBound, upperBound) {\n        this.lowerBound = lowerBound;\n        this.upperBound = upperBound;\n    }\n    static fixed(value) {\n        return new TypeCardinality(value, value);\n    }\n    static variable(value) {\n        return new TypeCardinality(0, value);\n    }\n    isSingular() {\n        return this.lowerBound == 1 && this.upperBound == 1;\n    }\n    isSingularOrNone() {\n        return this.lowerBound == 0 && this.upperBound == 1;\n    }\n    isComposite() {\n        return this.upperBound != 1;\n    }\n    isFixed() {\n        return this.lowerBound == this.upperBound;\n    }\n    getLowerBound() {\n        return this.lowerBound;\n    }\n    getUpperBound() {\n        return this.upperBound || TypeCardinality.MaxCardinality;\n    }\n}\nexports.TypeCardinality = TypeCardinality;\n/**\n * An arbitrarily chosen, reasonably large number.\n */\nTypeCardinality.MaxCardinality = 4096;\nclass PrimitiveType extends Type {\n    constructor(name) {\n        super(name);\n    }\n}\nexports.PrimitiveType = PrimitiveType;\nclass CustomType extends Type {\n}\nexports.CustomType = CustomType;\nclass TypedValue {\n    constructor(type) {\n        this.type = type;\n    }\n    getType() {\n        return this.type;\n    }\n}\nexports.TypedValue = TypedValue;\nclass PrimitiveValue extends TypedValue {\n    constructor(type) {\n        super(type);\n    }\n}\nexports.PrimitiveValue = PrimitiveValue;\nfunction isTyped(value) {\n    return value instanceof TypedValue;\n}\nexports.isTyped = isTyped;\nclass TypePlaceholder extends Type {\n    constructor() {\n        super(\"...\");\n    }\n}\nexports.TypePlaceholder = TypePlaceholder;\nclass NullType extends Type {\n    constructor() {\n        super(\"?\");\n    }\n}\nexports.NullType = NullType;\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"script"}