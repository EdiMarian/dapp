{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeExpressionParser = void 0;\n\nvar errors = __importStar(require(\"../../errors\"));\n\nvar types_1 = require(\"./types\");\n\nvar jsonHandler = require(\"json-duplicate-key-handle\");\n\nvar TypeExpressionParser = /*#__PURE__*/function () {\n  function TypeExpressionParser() {\n    _classCallCheck(this, TypeExpressionParser);\n  }\n\n  _createClass(TypeExpressionParser, [{\n    key: \"parse\",\n    value: function parse(expression) {\n      var root = this.doParse(expression);\n      var rootKeys = Object.keys(root);\n\n      if (rootKeys.length != 1) {\n        throw new errors.ErrTypingSystem(\"bad type expression: \".concat(expression));\n      }\n\n      var name = rootKeys[0];\n      var type = this.nodeToType(name, root[name]);\n      return type;\n    }\n  }, {\n    key: \"doParse\",\n    value: function doParse(expression) {\n      var jsoned = this.getJsonedString(expression);\n\n      try {\n        return jsonHandler.parse(jsoned);\n      } catch (error) {\n        throw new errors.ErrTypingSystem(\"cannot parse type expression: \".concat(expression, \". internal json: \").concat(jsoned, \".\"));\n      }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n\n  }, {\n    key: \"getJsonedString\",\n    value: function getJsonedString(expression) {\n      var jsoned = \"\";\n\n      for (var i = 0; i < expression.length; i++) {\n        var char = expression.charAt(i);\n        var previousChar = expression.charAt(i - 1);\n        var nextChar = expression.charAt(i + 1);\n\n        if (char == \"<\") {\n          jsoned += \": {\";\n        } else if (char == \">\") {\n          if (previousChar != \">\") {\n            jsoned += \": {} }\";\n          } else {\n            jsoned += \"}\";\n          }\n        } else if (char == \",\") {\n          if (nextChar == \">\") {// Skip superfluous comma\n          } else {\n            jsoned += \": {},\";\n          }\n        } else {\n          jsoned += char;\n        }\n      } // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n\n\n      var symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n      var tokens = jsoned // Hack for Safari compatibility, where we can't use negative lookbehind\n      .replace(/utf\\-8\\sstring/ig, \"utf-8-string\").split(symbolsRegex).filter(function (token) {\n        return token;\n      });\n      jsoned = tokens.map(function (token) {\n        return symbolsRegex.test(token) ? token : \"\\\"\".concat(token, \"\\\"\");\n      }).map(function (token) {\n        return token.replace(/utf\\-8\\-string/ig, \"utf-8 string\");\n      }).join(\"\");\n\n      if (tokens.length == 1) {\n        // Workaround for simple, non-generic types.\n        return \"{\".concat(jsoned, \": {}}\");\n      }\n\n      return \"{\".concat(jsoned, \"}\");\n    }\n  }, {\n    key: \"nodeToType\",\n    value: function nodeToType(name, node) {\n      var _this = this;\n\n      if (name.charAt(name.length - 1) === \"1\") {\n        name = name.slice(0, -1);\n      }\n\n      var typeParameters = Object.keys(node).map(function (key) {\n        return _this.nodeToType(key, node[key]);\n      });\n      return new types_1.Type(name, typeParameters);\n    }\n  }]);\n\n  return TypeExpressionParser;\n}();\n\nexports.TypeExpressionParser = TypeExpressionParser;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/typeExpressionParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeExpressionParser = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst types_1 = require(\"./types\");\nvar jsonHandler = require(\"json-duplicate-key-handle\");\nclass TypeExpressionParser {\n    parse(expression) {\n        let root = this.doParse(expression);\n        let rootKeys = Object.keys(root);\n        if (rootKeys.length != 1) {\n            throw new errors.ErrTypingSystem(`bad type expression: ${expression}`);\n        }\n        let name = rootKeys[0];\n        let type = this.nodeToType(name, root[name]);\n        return type;\n    }\n    doParse(expression) {\n        let jsoned = this.getJsonedString(expression);\n        try {\n            return jsonHandler.parse(jsoned);\n        }\n        catch (error) {\n            throw new errors.ErrTypingSystem(`cannot parse type expression: ${expression}. internal json: ${jsoned}.`);\n        }\n    }\n    /**\n     * Converts a raw type expression to a JSON, parsing-friendly format.\n     * This is a workaround, so that the parser implementation is simpler (thus we actually rely on the JSON parser).\n     *\n     * @param expression a string such as:\n     *\n     * ```\n     *  - Option<List<Address>>\n     *  - VarArgs<MultiArg2<bytes, Address>>\n     *  - MultiResultVec<MultiResult2<Address, u64>\n     * ```\n     */\n    getJsonedString(expression) {\n        let jsoned = \"\";\n        for (var i = 0; i < expression.length; i++) {\n            let char = expression.charAt(i);\n            let previousChar = expression.charAt(i - 1);\n            let nextChar = expression.charAt(i + 1);\n            if (char == \"<\") {\n                jsoned += \": {\";\n            }\n            else if (char == \">\") {\n                if (previousChar != \">\") {\n                    jsoned += \": {} }\";\n                }\n                else {\n                    jsoned += \"}\";\n                }\n            }\n            else if (char == \",\") {\n                if (nextChar == \">\") {\n                    // Skip superfluous comma\n                }\n                else {\n                    jsoned += \": {},\";\n                }\n            }\n            else {\n                jsoned += char;\n            }\n        }\n        // Split by the delimiters, but exclude the spaces that are found in the middle of \"utf-8 string\"\n        let symbolsRegex = /(:|\\{|\\}|,|\\s)/;\n        let tokens = jsoned\n            // Hack for Safari compatibility, where we can't use negative lookbehind\n            .replace(/utf\\-8\\sstring/ig, \"utf-8-string\")\n            .split(symbolsRegex)\n            .filter((token) => token);\n        jsoned = tokens.map((token) => (symbolsRegex.test(token) ? token : `\"${token}\"`))\n            .map((token) => token.replace(/utf\\-8\\-string/ig, \"utf-8 string\"))\n            .join(\"\");\n        if (tokens.length == 1) {\n            // Workaround for simple, non-generic types.\n            return `{${jsoned}: {}}`;\n        }\n        return `{${jsoned}}`;\n    }\n    nodeToType(name, node) {\n        if (name.charAt(name.length - 1) === \"1\") {\n            name = name.slice(0, -1);\n        }\n        let typeParameters = Object.keys(node).map((key) => this.nodeToType(key, node[key]));\n        return new types_1.Type(name, typeParameters);\n    }\n}\nexports.TypeExpressionParser = TypeExpressionParser;\n//# sourceMappingURL=typeExpressionParser.js.map"]},"metadata":{},"sourceType":"script"}