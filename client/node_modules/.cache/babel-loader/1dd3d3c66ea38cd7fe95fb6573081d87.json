{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\n\nvar utils_1 = require(\"../../utils\");\n\nvar collections_1 = require(\"./collections\");\n\nvar types_1 = require(\"./types\"); // TODO: Move to a new file, \"genericOption.ts\"\n\n\nvar OptionType = /*#__PURE__*/function (_types_1$Type) {\n  _inherits(OptionType, _types_1$Type);\n\n  var _super = _createSuper(OptionType);\n\n  function OptionType(typeParameter) {\n    _classCallCheck(this, OptionType);\n\n    return _super.call(this, \"Option\", [typeParameter]);\n  }\n\n  _createClass(OptionType, [{\n    key: \"isAssignableFrom\",\n    value: function isAssignableFrom(type) {\n      if (!(type instanceof OptionType)) {\n        return false;\n      }\n\n      var invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n      var fakeCovarianceToNull = type.getFirstTypeParameter() instanceof types_1.NullType;\n      return invariantTypeParameters || fakeCovarianceToNull;\n    }\n  }]);\n\n  return OptionType;\n}(types_1.Type);\n\nexports.OptionType = OptionType; // TODO: Move to a new file, \"genericList.ts\"\n\nvar ListType = /*#__PURE__*/function (_types_1$Type2) {\n  _inherits(ListType, _types_1$Type2);\n\n  var _super2 = _createSuper(ListType);\n\n  function ListType(typeParameter) {\n    _classCallCheck(this, ListType);\n\n    return _super2.call(this, \"List\", [typeParameter]);\n  }\n\n  return ListType;\n}(types_1.Type);\n\nexports.ListType = ListType; // TODO: Move to a new file, \"genericOption.ts\"\n\nvar OptionValue = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(OptionValue, _types_1$TypedValue);\n\n  var _super3 = _createSuper(OptionValue);\n\n  function OptionValue(type) {\n    var _this;\n\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, OptionValue);\n\n    _this = _super3.call(this, type); // TODO: assert value is of type type.getFirstTypeParameter()\n\n    _this.value = value;\n    return _this;\n  }\n  /**\n   * Creates an OptionValue, as a missing option argument.\n   */\n\n\n  _createClass(OptionValue, [{\n    key: \"isSet\",\n    value: function isSet() {\n      return this.value ? true : false;\n    }\n  }, {\n    key: \"getTypedValue\",\n    value: function getTypedValue() {\n      utils_1.guardValueIsSet(\"value\", this.value);\n      return this.value;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value ? this.value.valueOf() : null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      var _a;\n\n      return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n  }], [{\n    key: \"newMissing\",\n    value: function newMissing() {\n      var type = new OptionType(new types_1.NullType());\n      return new OptionValue(type);\n    }\n  }, {\n    key: \"newMissingType\",\n    value: function newMissingType(type) {\n      return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n\n  }, {\n    key: \"newProvided\",\n    value: function newProvided(typedValue) {\n      var type = new OptionType(typedValue.getType());\n      return new OptionValue(type, typedValue);\n    }\n  }]);\n\n  return OptionValue;\n}(types_1.TypedValue);\n\nexports.OptionValue = OptionValue; // TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\n\nvar List = /*#__PURE__*/function (_types_1$TypedValue2) {\n  _inherits(List, _types_1$TypedValue2);\n\n  var _super4 = _createSuper(List);\n\n  /**\n   *\n   * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n   * @param items the items, having the type type.getFirstTypeParameter()\n   */\n  function List(type, items) {\n    var _this2;\n\n    _classCallCheck(this, List);\n\n    _this2 = _super4.call(this, type); // TODO: assert items are of type type.getFirstTypeParameter()\n\n    _this2.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    return _this2;\n  }\n\n  _createClass(List, [{\n    key: \"getLength\",\n    value: function getLength() {\n      return this.backingCollection.getLength();\n    }\n  }, {\n    key: \"getItems\",\n    value: function getItems() {\n      return this.backingCollection.getItems();\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.backingCollection.valueOf();\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.backingCollection.equals(other.backingCollection);\n    }\n  }], [{\n    key: \"fromItems\",\n    value: function fromItems(items) {\n      if (items.length == 0) {\n        return new List(new types_1.TypePlaceholder(), []);\n      }\n\n      var typeParameter = items[0].getType();\n      var listType = new ListType(typeParameter);\n      return new List(listType, items);\n    }\n  }]);\n\n  return List;\n}(types_1.TypedValue);\n\nexports.List = List;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/generic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.List = exports.OptionValue = exports.ListType = exports.OptionType = void 0;\nconst utils_1 = require(\"../../utils\");\nconst collections_1 = require(\"./collections\");\nconst types_1 = require(\"./types\");\n// TODO: Move to a new file, \"genericOption.ts\"\nclass OptionType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"Option\", [typeParameter]);\n    }\n    isAssignableFrom(type) {\n        if (!(type instanceof OptionType)) {\n            return false;\n        }\n        let invariantTypeParameters = this.getFirstTypeParameter().equals(type.getFirstTypeParameter());\n        let fakeCovarianceToNull = type.getFirstTypeParameter() instanceof types_1.NullType;\n        return invariantTypeParameters || fakeCovarianceToNull;\n    }\n}\nexports.OptionType = OptionType;\n// TODO: Move to a new file, \"genericList.ts\"\nclass ListType extends types_1.Type {\n    constructor(typeParameter) {\n        super(\"List\", [typeParameter]);\n    }\n}\nexports.ListType = ListType;\n// TODO: Move to a new file, \"genericOption.ts\"\nclass OptionValue extends types_1.TypedValue {\n    constructor(type, value = null) {\n        super(type);\n        // TODO: assert value is of type type.getFirstTypeParameter()\n        this.value = value;\n    }\n    /**\n     * Creates an OptionValue, as a missing option argument.\n     */\n    static newMissing() {\n        let type = new OptionType(new types_1.NullType());\n        return new OptionValue(type);\n    }\n    static newMissingType(type) {\n        return new OptionValue(new OptionType(type));\n    }\n    /**\n     * Creates an OptionValue, as a provided option argument.\n     */\n    static newProvided(typedValue) {\n        let type = new OptionType(typedValue.getType());\n        return new OptionValue(type, typedValue);\n    }\n    isSet() {\n        return this.value ? true : false;\n    }\n    getTypedValue() {\n        utils_1.guardValueIsSet(\"value\", this.value);\n        return this.value;\n    }\n    valueOf() {\n        return this.value ? this.value.valueOf() : null;\n    }\n    equals(other) {\n        var _a;\n        return ((_a = this.value) === null || _a === void 0 ? void 0 : _a.equals(other.value)) || false;\n    }\n}\nexports.OptionValue = OptionValue;\n// TODO: Move to a new file, \"genericList.ts\"\n// TODO: Rename to ListValue, for consistency (though the term is slighly unfortunate).\n// Question for review: or not?\nclass List extends types_1.TypedValue {\n    /**\n     *\n     * @param type the type of this TypedValue (an instance of ListType), not the type parameter of the ListType\n     * @param items the items, having the type type.getFirstTypeParameter()\n     */\n    constructor(type, items) {\n        super(type);\n        // TODO: assert items are of type type.getFirstTypeParameter()\n        this.backingCollection = new collections_1.CollectionOfTypedValues(items);\n    }\n    static fromItems(items) {\n        if (items.length == 0) {\n            return new List(new types_1.TypePlaceholder(), []);\n        }\n        let typeParameter = items[0].getType();\n        let listType = new ListType(typeParameter);\n        return new List(listType, items);\n    }\n    getLength() {\n        return this.backingCollection.getLength();\n    }\n    getItems() {\n        return this.backingCollection.getItems();\n    }\n    valueOf() {\n        return this.backingCollection.valueOf();\n    }\n    equals(other) {\n        return this.backingCollection.equals(other.backingCollection);\n    }\n}\nexports.List = List;\n//# sourceMappingURL=generic.js.map"]},"metadata":{},"sourceType":"script"}