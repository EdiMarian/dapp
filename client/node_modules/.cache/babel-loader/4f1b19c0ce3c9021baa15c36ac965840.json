{"ast":null,"code":"\"use strict\";\n\nvar _inherits = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TransactionStatus = exports.TransactionHash = exports.Transaction = void 0;\n\nvar bignumber_js_1 = require(\"bignumber.js\");\n\nvar address_1 = require(\"./address\");\n\nvar balance_1 = require(\"./balance\");\n\nvar networkParams_1 = require(\"./networkParams\");\n\nvar networkConfig_1 = require(\"./networkConfig\");\n\nvar nonce_1 = require(\"./nonce\");\n\nvar signature_1 = require(\"./signature\");\n\nvar utils_1 = require(\"./utils\");\n\nvar transactionPayload_1 = require(\"./transactionPayload\");\n\nvar errors = __importStar(require(\"./errors\"));\n\nvar events_1 = require(\"./events\");\n\nvar transactionWatcher_1 = require(\"./transactionWatcher\");\n\nvar proto_1 = require(\"./proto\");\n\nvar transactionOnNetwork_1 = require(\"./transactionOnNetwork\");\n\nvar hash_1 = require(\"./hash\");\n\nvar createTransactionHasher = require(\"blake2b\");\n\nvar TRANSACTION_HASH_LENGTH = 32;\n/**\n * An abstraction for creating, signing and broadcasting Elrond transactions.\n */\n\nvar Transaction = /*#__PURE__*/function () {\n  /**\n   * Creates a new Transaction object.\n   */\n  function Transaction(_ref) {\n    var nonce = _ref.nonce,\n        value = _ref.value,\n        receiver = _ref.receiver,\n        sender = _ref.sender,\n        gasPrice = _ref.gasPrice,\n        gasLimit = _ref.gasLimit,\n        data = _ref.data,\n        chainID = _ref.chainID,\n        version = _ref.version,\n        options = _ref.options;\n\n    _classCallCheck(this, Transaction);\n\n    /**\n     * A (cached) representation of the transaction, as fetched from the API.\n     */\n    this.asOnNetwork = new transactionOnNetwork_1.TransactionOnNetwork();\n    this.nonce = nonce || new nonce_1.Nonce(0);\n    this.value = value || balance_1.Balance.Zero();\n    this.sender = sender || address_1.Address.Zero();\n    this.receiver = receiver;\n    this.gasPrice = gasPrice || networkConfig_1.NetworkConfig.getDefault().MinGasPrice;\n    this.gasLimit = gasLimit || networkConfig_1.NetworkConfig.getDefault().MinGasLimit;\n    this.data = data || new transactionPayload_1.TransactionPayload();\n    this.chainID = chainID || networkConfig_1.NetworkConfig.getDefault().ChainID;\n    this.version = version || networkParams_1.TransactionVersion.withDefaultVersion();\n    this.options = options || networkParams_1.TransactionOptions.withDefaultOptions();\n    this.signature = signature_1.Signature.empty();\n    this.hash = TransactionHash.empty();\n    this.status = TransactionStatus.createUnknown();\n    this.onSigned = new events_1.TypedEvent();\n    this.onSent = new events_1.TypedEvent();\n    this.onStatusUpdated = new events_1.TypedEvent();\n    this.onStatusChanged = new events_1.TypedEvent(); // We apply runtime type checks for these fields, since they are the most commonly misused when calling the Transaction constructor\n    // in JavaScript (which lacks type safety).\n\n    utils_1.guardType(\"nonce\", nonce_1.Nonce, this.nonce);\n    utils_1.guardType(\"gasLimit\", networkParams_1.GasLimit, this.gasLimit);\n    utils_1.guardType(\"gasPrice\", networkParams_1.GasPrice, this.gasPrice);\n  }\n\n  _createClass(Transaction, [{\n    key: \"getNonce\",\n    value: function getNonce() {\n      return this.nonce;\n    }\n    /**\n     * Sets the account sequence number of the sender. Must be done prior signing.\n     *\n     * ```\n     * await alice.sync(provider);\n     *\n     * let tx = new Transaction({\n     *      value: Balance.egld(1),\n     *      receiver: bob.address\n     * });\n     *\n     * tx.setNonce(alice.nonce);\n     * await alice.signer.sign(tx);\n     * ```\n     */\n\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(nonce) {\n      this.nonce = nonce;\n      this.doAfterPropertySetter();\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      this.value = value;\n      this.doAfterPropertySetter();\n    }\n  }, {\n    key: \"getSender\",\n    value: function getSender() {\n      return this.sender;\n    }\n  }, {\n    key: \"getReceiver\",\n    value: function getReceiver() {\n      return this.receiver;\n    }\n  }, {\n    key: \"getGasPrice\",\n    value: function getGasPrice() {\n      return this.gasPrice;\n    }\n  }, {\n    key: \"setGasPrice\",\n    value: function setGasPrice(gasPrice) {\n      this.gasPrice = gasPrice;\n      this.doAfterPropertySetter();\n    }\n  }, {\n    key: \"getGasLimit\",\n    value: function getGasLimit() {\n      return this.gasLimit;\n    }\n  }, {\n    key: \"setGasLimit\",\n    value: function setGasLimit(gasLimit) {\n      this.gasLimit = gasLimit;\n      this.doAfterPropertySetter();\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.data;\n    }\n  }, {\n    key: \"getChainID\",\n    value: function getChainID() {\n      return this.chainID;\n    }\n  }, {\n    key: \"getVersion\",\n    value: function getVersion() {\n      return this.version;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return this.options;\n    }\n  }, {\n    key: \"doAfterPropertySetter\",\n    value: function doAfterPropertySetter() {\n      this.signature = signature_1.Signature.empty();\n      this.hash = TransactionHash.empty();\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      utils_1.guardNotEmpty(this.signature, \"signature\");\n      return this.signature;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      utils_1.guardNotEmpty(this.hash, \"hash\");\n      return this.hash;\n    }\n  }, {\n    key: \"getStatus\",\n    value: function getStatus() {\n      return this.status;\n    }\n    /**\n     * Serializes a transaction to a sequence of bytes, ready to be signed.\n     * This function is called internally, by {@link Signer} objects.\n     *\n     * @param signedBy The address of the future signer\n     */\n\n  }, {\n    key: \"serializeForSigning\",\n    value: function serializeForSigning(signedBy) {\n      // TODO: for appropriate tx.version, interpret tx.options accordingly and sign using the content / data hash\n      var plain = this.toPlainObject(signedBy); // Make sure we never sign the transaction with another signature set up (useful when using the same method for verification)\n\n      if (plain.signature) {\n        delete plain.signature;\n      }\n\n      var serialized = JSON.stringify(plain);\n      return Buffer.from(serialized);\n    }\n    /**\n     * Converts the transaction object into a ready-to-serialize, plain JavaScript object.\n     * This function is called internally within the signing procedure.\n     *\n     * @param sender The address of the sender (will be provided when called within the signing procedure)\n     */\n\n  }, {\n    key: \"toPlainObject\",\n    value: function toPlainObject(sender) {\n      return {\n        nonce: this.nonce.valueOf(),\n        value: this.value.toString(),\n        receiver: this.receiver.bech32(),\n        sender: sender ? sender.bech32() : this.sender.bech32(),\n        gasPrice: this.gasPrice.valueOf(),\n        gasLimit: this.gasLimit.valueOf(),\n        data: this.data.isEmpty() ? undefined : this.data.encoded(),\n        chainID: this.chainID.valueOf(),\n        version: this.version.valueOf(),\n        options: this.options.valueOf() == 0 ? undefined : this.options.valueOf(),\n        signature: this.signature.isEmpty() ? undefined : this.signature.hex()\n      };\n    }\n    /**\n     * Converts a plain object transaction into a Transaction Object.\n     *\n     * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()\n     */\n\n  }, {\n    key: \"applySignature\",\n    value:\n    /**\n     * Applies the signature on the transaction.\n     *\n     * @param signature The signature, as computed by a {@link ISigner}.\n     * @param signedBy The address of the signer.\n     */\n    function applySignature(signature, signedBy) {\n      utils_1.guardEmpty(this.signature, \"signature\");\n      utils_1.guardEmpty(this.hash, \"hash\");\n      this.signature = signature;\n      this.sender = signedBy;\n      this.hash = TransactionHash.compute(this);\n      this.onSigned.emit({\n        transaction: this,\n        signedBy: signedBy\n      });\n    }\n    /**\n     * Broadcasts a transaction to the Network, via a {@link IProvider}.\n     *\n     * ```\n     * let provider = new ProxyProvider(\"https://gateway.elrond.com\");\n     * // ... Prepare, sign the transaction, then:\n     * await tx.send(provider);\n     * await tx.awaitExecuted(provider);\n     * ```\n     */\n\n  }, {\n    key: \"send\",\n    value: function send(provider) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return provider.sendTransaction(this);\n\n              case 2:\n                this.hash = _context.sent;\n                this.onSent.emit({\n                  transaction: this\n                });\n                return _context.abrupt(\"return\", this.hash);\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Simulates a transaction on the Network, via a {@link IProvider}.\n     */\n\n  }, {\n    key: \"simulate\",\n    value: function simulate(provider) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return provider.simulateTransaction(this);\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Converts a transaction to a ready-to-broadcast object.\n     * Called internally by the {@link IProvider}.\n     */\n\n  }, {\n    key: \"toSendable\",\n    value: function toSendable() {\n      if (this.signature.isEmpty()) {\n        throw new errors.ErrTransactionNotSigned();\n      }\n\n      return this.toPlainObject();\n    }\n    /**\n     * Fetches a representation of the transaction (whether pending, processed or finalized), as found on the Network.\n     *\n     * @param fetcher The transaction fetcher to use\n     * @param cacheLocally Whether to cache the response locally, on the transaction object\n     * @param awaitNotarized Whether to wait for the transaction to be notarized\n     * @param withResults Whether to wait for the transaction results\n     */\n\n  }, {\n    key: \"getAsOnNetwork\",\n    value: function getAsOnNetwork(fetcher) {\n      var cacheLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var awaitNotarized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var withResults = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var isSmartContractTransaction, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.hash.isEmpty()) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new errors.ErrTransactionHashUnknown();\n\n              case 2:\n                // For Smart Contract transactions, wait for their full execution & notarization before returning.\n                isSmartContractTransaction = this.receiver.isContractAddress();\n\n                if (!(isSmartContractTransaction && awaitNotarized)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 6;\n                return this.awaitNotarized(fetcher);\n\n              case 6:\n                _context3.next = 8;\n                return fetcher.getTransaction(this.hash, this.sender, withResults);\n\n              case 8:\n                response = _context3.sent;\n\n                if (cacheLocally) {\n                  this.asOnNetwork = response;\n                }\n\n                return _context3.abrupt(\"return\", response);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Returns the cached representation of the transaction, as previously fetched using {@link Transaction.getAsOnNetwork}.\n     */\n\n  }, {\n    key: \"getAsOnNetworkCached\",\n    value: function getAsOnNetworkCached() {\n      return this.asOnNetwork;\n    }\n  }, {\n    key: \"awaitSigned\",\n    value: function awaitSigned() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.signature.isEmpty()) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                return _context4.abrupt(\"return\", new Promise(function (resolve, _reject) {\n                  _this.onSigned.on(function () {\n                    return resolve();\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"awaitHashed\",\n    value: function awaitHashed() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.hash.isEmpty()) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 2:\n                return _context5.abrupt(\"return\", new Promise(function (resolve, _reject) {\n                  _this2.onSigned.on(function () {\n                    return resolve();\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties\n     * @param networkConfig {@link NetworkConfig}\n     */\n\n  }, {\n    key: \"computeFee\",\n    value: function computeFee(networkConfig) {\n      var moveBalanceGas = networkConfig.MinGasLimit.valueOf() + this.data.length() * networkConfig.GasPerDataByte.valueOf();\n\n      if (moveBalanceGas > this.gasLimit.valueOf()) {\n        throw new errors.ErrNotEnoughGas(this.gasLimit.valueOf());\n      }\n\n      var gasPrice = new bignumber_js_1.BigNumber(this.gasPrice.valueOf());\n      var feeForMove = new bignumber_js_1.BigNumber(moveBalanceGas).multipliedBy(gasPrice);\n\n      if (moveBalanceGas === this.gasLimit.valueOf()) {\n        return feeForMove;\n      }\n\n      var diff = new bignumber_js_1.BigNumber(this.gasLimit.valueOf() - moveBalanceGas);\n      var modifiedGasPrice = gasPrice.multipliedBy(new bignumber_js_1.BigNumber(networkConfig.GasPriceModifier.valueOf()));\n      var processingFee = diff.multipliedBy(modifiedGasPrice);\n      return feeForMove.plus(processingFee);\n    }\n    /**\n     * Awaits for a transaction to reach its \"pending\" state - that is, for the transaction to be accepted in the mempool.\n     * Performs polling against the provider, via a {@link TransactionWatcher}.\n     */\n\n  }, {\n    key: \"awaitPending\",\n    value: function awaitPending(fetcher) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var watcher;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                watcher = new transactionWatcher_1.TransactionWatcher(this.hash, fetcher);\n                _context6.next = 3;\n                return watcher.awaitPending(this.notifyStatusUpdate.bind(this));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Awaits for a transaction to reach its \"executed\" state - that is, for the transaction to be processed (whether with success or with errors).\n     * Performs polling against the provider, via a {@link TransactionWatcher}.\n     */\n\n  }, {\n    key: \"awaitExecuted\",\n    value: function awaitExecuted(fetcher) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var watcher;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                watcher = new transactionWatcher_1.TransactionWatcher(this.hash, fetcher);\n                _context7.next = 3;\n                return watcher.awaitExecuted(this.notifyStatusUpdate.bind(this));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"notifyStatusUpdate\",\n    value: function notifyStatusUpdate(newStatus) {\n      var sameStatus = this.status.equals(newStatus);\n      this.onStatusUpdated.emit({\n        transaction: this\n      });\n\n      if (!sameStatus) {\n        this.status = newStatus;\n        this.onStatusChanged.emit({\n          transaction: this\n        });\n      }\n    }\n  }, {\n    key: \"awaitNotarized\",\n    value: function awaitNotarized(fetcher) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var watcher;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                watcher = new transactionWatcher_1.TransactionWatcher(this.hash, fetcher);\n                _context8.next = 3;\n                return watcher.awaitNotarized();\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }], [{\n    key: \"fromPlainObject\",\n    value: function fromPlainObject(plainObjectTransaction) {\n      var tx = new Transaction({\n        nonce: new nonce_1.Nonce(plainObjectTransaction.nonce),\n        value: balance_1.Balance.fromString(plainObjectTransaction.value),\n        receiver: address_1.Address.fromString(plainObjectTransaction.receiver),\n        gasPrice: new networkParams_1.GasPrice(plainObjectTransaction.gasPrice),\n        gasLimit: new networkParams_1.GasLimit(plainObjectTransaction.gasLimit),\n        data: new transactionPayload_1.TransactionPayload(atob(plainObjectTransaction.data)),\n        chainID: new networkParams_1.ChainID(plainObjectTransaction.chainID),\n        version: new networkParams_1.TransactionVersion(plainObjectTransaction.version)\n      });\n\n      if (plainObjectTransaction.signature) {\n        tx.applySignature(new signature_1.Signature(plainObjectTransaction.signature), address_1.Address.fromString(plainObjectTransaction.sender));\n      }\n\n      return tx;\n    }\n  }]);\n\n  return Transaction;\n}();\n\nexports.Transaction = Transaction;\n/**\n * An abstraction for handling and computing transaction hashes.\n */\n\nvar TransactionHash = /*#__PURE__*/function (_hash_1$Hash) {\n  _inherits(TransactionHash, _hash_1$Hash);\n\n  var _super = _createSuper(TransactionHash);\n\n  function TransactionHash(hash) {\n    _classCallCheck(this, TransactionHash);\n\n    return _super.call(this, hash);\n  }\n  /**\n   * Computes the hash of a transaction.\n   * Not yet implemented.\n   */\n\n\n  _createClass(TransactionHash, null, [{\n    key: \"compute\",\n    value: function compute(transaction) {\n      var serializer = new proto_1.ProtoSerializer();\n      var buffer = serializer.serializeTransaction(transaction);\n      var hash = createTransactionHasher(TRANSACTION_HASH_LENGTH).update(buffer).digest(\"hex\");\n      return new TransactionHash(hash);\n    }\n  }]);\n\n  return TransactionHash;\n}(hash_1.Hash);\n\nexports.TransactionHash = TransactionHash;\n/**\n * An abstraction for handling and interpreting the \"status\" field of a {@link Transaction}.\n */\n\nvar TransactionStatus = /*#__PURE__*/function () {\n  /**\n   * Creates a new TransactionStatus object.\n   */\n  function TransactionStatus(status) {\n    _classCallCheck(this, TransactionStatus);\n\n    this.status = (status || \"\").toLowerCase();\n  }\n  /**\n   * Creates an unknown status.\n   */\n\n\n  _createClass(TransactionStatus, [{\n    key: \"isPending\",\n    value:\n    /**\n     * Returns whether the transaction is pending (e.g. in mempool).\n     */\n    function isPending() {\n      return this.status == \"received\" || this.status == \"pending\" || this.status == \"partially-executed\";\n    }\n    /**\n     * Returns whether the transaction has been executed (not necessarily with success).\n     */\n\n  }, {\n    key: \"isExecuted\",\n    value: function isExecuted() {\n      return this.isSuccessful() || this.isInvalid();\n    }\n    /**\n     * Returns whether the transaction has been executed successfully.\n     */\n\n  }, {\n    key: \"isSuccessful\",\n    value: function isSuccessful() {\n      return this.status == \"executed\" || this.status == \"success\" || this.status == \"successful\";\n    }\n    /**\n     * Returns whether the transaction has been executed, but with a failure.\n     */\n\n  }, {\n    key: \"isFailed\",\n    value: function isFailed() {\n      return this.status == \"fail\" || this.status == \"failed\" || this.status == \"unsuccessful\" || this.isInvalid();\n    }\n    /**\n     * Returns whether the transaction has been executed, but marked as invalid (e.g. due to \"insufficient funds\").\n     */\n\n  }, {\n    key: \"isInvalid\",\n    value: function isInvalid() {\n      return this.status == \"invalid\";\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.status;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.status;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!other) {\n        return false;\n      }\n\n      return this.status == other.status;\n    }\n  }], [{\n    key: \"createUnknown\",\n    value: function createUnknown() {\n      return new TransactionStatus(\"unknown\");\n    }\n  }]);\n\n  return TransactionStatus;\n}();\n\nexports.TransactionStatus = TransactionStatus;","map":{"version":3,"sources":["../src/transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransactionStatus = exports.TransactionHash = exports.Transaction = void 0;\nconst bignumber_js_1 = require(\"bignumber.js\");\nconst address_1 = require(\"./address\");\nconst balance_1 = require(\"./balance\");\nconst networkParams_1 = require(\"./networkParams\");\nconst networkConfig_1 = require(\"./networkConfig\");\nconst nonce_1 = require(\"./nonce\");\nconst signature_1 = require(\"./signature\");\nconst utils_1 = require(\"./utils\");\nconst transactionPayload_1 = require(\"./transactionPayload\");\nconst errors = __importStar(require(\"./errors\"));\nconst events_1 = require(\"./events\");\nconst transactionWatcher_1 = require(\"./transactionWatcher\");\nconst proto_1 = require(\"./proto\");\nconst transactionOnNetwork_1 = require(\"./transactionOnNetwork\");\nconst hash_1 = require(\"./hash\");\nconst createTransactionHasher = require(\"blake2b\");\nconst TRANSACTION_HASH_LENGTH = 32;\n/**\n * An abstraction for creating, signing and broadcasting Elrond transactions.\n */\nclass Transaction {\n    /**\n     * Creates a new Transaction object.\n     */\n    constructor({ nonce, value, receiver, sender, gasPrice, gasLimit, data, chainID, version, options, }) {\n        /**\n         * A (cached) representation of the transaction, as fetched from the API.\n         */\n        this.asOnNetwork = new transactionOnNetwork_1.TransactionOnNetwork();\n        this.nonce = nonce || new nonce_1.Nonce(0);\n        this.value = value || balance_1.Balance.Zero();\n        this.sender = sender || address_1.Address.Zero();\n        this.receiver = receiver;\n        this.gasPrice = gasPrice || networkConfig_1.NetworkConfig.getDefault().MinGasPrice;\n        this.gasLimit = gasLimit || networkConfig_1.NetworkConfig.getDefault().MinGasLimit;\n        this.data = data || new transactionPayload_1.TransactionPayload();\n        this.chainID = chainID || networkConfig_1.NetworkConfig.getDefault().ChainID;\n        this.version = version || networkParams_1.TransactionVersion.withDefaultVersion();\n        this.options = options || networkParams_1.TransactionOptions.withDefaultOptions();\n        this.signature = signature_1.Signature.empty();\n        this.hash = TransactionHash.empty();\n        this.status = TransactionStatus.createUnknown();\n        this.onSigned = new events_1.TypedEvent();\n        this.onSent = new events_1.TypedEvent();\n        this.onStatusUpdated = new events_1.TypedEvent();\n        this.onStatusChanged = new events_1.TypedEvent();\n        // We apply runtime type checks for these fields, since they are the most commonly misused when calling the Transaction constructor\n        // in JavaScript (which lacks type safety).\n        utils_1.guardType(\"nonce\", nonce_1.Nonce, this.nonce);\n        utils_1.guardType(\"gasLimit\", networkParams_1.GasLimit, this.gasLimit);\n        utils_1.guardType(\"gasPrice\", networkParams_1.GasPrice, this.gasPrice);\n    }\n    getNonce() {\n        return this.nonce;\n    }\n    /**\n     * Sets the account sequence number of the sender. Must be done prior signing.\n     *\n     * ```\n     * await alice.sync(provider);\n     *\n     * let tx = new Transaction({\n     *      value: Balance.egld(1),\n     *      receiver: bob.address\n     * });\n     *\n     * tx.setNonce(alice.nonce);\n     * await alice.signer.sign(tx);\n     * ```\n     */\n    setNonce(nonce) {\n        this.nonce = nonce;\n        this.doAfterPropertySetter();\n    }\n    getValue() {\n        return this.value;\n    }\n    setValue(value) {\n        this.value = value;\n        this.doAfterPropertySetter();\n    }\n    getSender() {\n        return this.sender;\n    }\n    getReceiver() {\n        return this.receiver;\n    }\n    getGasPrice() {\n        return this.gasPrice;\n    }\n    setGasPrice(gasPrice) {\n        this.gasPrice = gasPrice;\n        this.doAfterPropertySetter();\n    }\n    getGasLimit() {\n        return this.gasLimit;\n    }\n    setGasLimit(gasLimit) {\n        this.gasLimit = gasLimit;\n        this.doAfterPropertySetter();\n    }\n    getData() {\n        return this.data;\n    }\n    getChainID() {\n        return this.chainID;\n    }\n    getVersion() {\n        return this.version;\n    }\n    getOptions() {\n        return this.options;\n    }\n    doAfterPropertySetter() {\n        this.signature = signature_1.Signature.empty();\n        this.hash = TransactionHash.empty();\n    }\n    getSignature() {\n        utils_1.guardNotEmpty(this.signature, \"signature\");\n        return this.signature;\n    }\n    getHash() {\n        utils_1.guardNotEmpty(this.hash, \"hash\");\n        return this.hash;\n    }\n    getStatus() {\n        return this.status;\n    }\n    /**\n     * Serializes a transaction to a sequence of bytes, ready to be signed.\n     * This function is called internally, by {@link Signer} objects.\n     *\n     * @param signedBy The address of the future signer\n     */\n    serializeForSigning(signedBy) {\n        // TODO: for appropriate tx.version, interpret tx.options accordingly and sign using the content / data hash\n        let plain = this.toPlainObject(signedBy);\n        // Make sure we never sign the transaction with another signature set up (useful when using the same method for verification)\n        if (plain.signature) {\n            delete plain.signature;\n        }\n        let serialized = JSON.stringify(plain);\n        return Buffer.from(serialized);\n    }\n    /**\n     * Converts the transaction object into a ready-to-serialize, plain JavaScript object.\n     * This function is called internally within the signing procedure.\n     *\n     * @param sender The address of the sender (will be provided when called within the signing procedure)\n     */\n    toPlainObject(sender) {\n        return {\n            nonce: this.nonce.valueOf(),\n            value: this.value.toString(),\n            receiver: this.receiver.bech32(),\n            sender: sender ? sender.bech32() : this.sender.bech32(),\n            gasPrice: this.gasPrice.valueOf(),\n            gasLimit: this.gasLimit.valueOf(),\n            data: this.data.isEmpty() ? undefined : this.data.encoded(),\n            chainID: this.chainID.valueOf(),\n            version: this.version.valueOf(),\n            options: this.options.valueOf() == 0 ? undefined : this.options.valueOf(),\n            signature: this.signature.isEmpty() ? undefined : this.signature.hex(),\n        };\n    }\n    /**\n     * Converts a plain object transaction into a Transaction Object.\n     *\n     * @param plainObjectTransaction Raw data of a transaction, usually obtained by calling toPlainObject()\n     */\n    static fromPlainObject(plainObjectTransaction) {\n        const tx = new Transaction({\n            nonce: new nonce_1.Nonce(plainObjectTransaction.nonce),\n            value: balance_1.Balance.fromString(plainObjectTransaction.value),\n            receiver: address_1.Address.fromString(plainObjectTransaction.receiver),\n            gasPrice: new networkParams_1.GasPrice(plainObjectTransaction.gasPrice),\n            gasLimit: new networkParams_1.GasLimit(plainObjectTransaction.gasLimit),\n            data: new transactionPayload_1.TransactionPayload(atob(plainObjectTransaction.data)),\n            chainID: new networkParams_1.ChainID(plainObjectTransaction.chainID),\n            version: new networkParams_1.TransactionVersion(plainObjectTransaction.version),\n        });\n        if (plainObjectTransaction.signature) {\n            tx.applySignature(new signature_1.Signature(plainObjectTransaction.signature), address_1.Address.fromString(plainObjectTransaction.sender));\n        }\n        return tx;\n    }\n    /**\n     * Applies the signature on the transaction.\n     *\n     * @param signature The signature, as computed by a {@link ISigner}.\n     * @param signedBy The address of the signer.\n     */\n    applySignature(signature, signedBy) {\n        utils_1.guardEmpty(this.signature, \"signature\");\n        utils_1.guardEmpty(this.hash, \"hash\");\n        this.signature = signature;\n        this.sender = signedBy;\n        this.hash = TransactionHash.compute(this);\n        this.onSigned.emit({ transaction: this, signedBy: signedBy });\n    }\n    /**\n     * Broadcasts a transaction to the Network, via a {@link IProvider}.\n     *\n     * ```\n     * let provider = new ProxyProvider(\"https://gateway.elrond.com\");\n     * // ... Prepare, sign the transaction, then:\n     * await tx.send(provider);\n     * await tx.awaitExecuted(provider);\n     * ```\n     */\n    send(provider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.hash = yield provider.sendTransaction(this);\n            this.onSent.emit({ transaction: this });\n            return this.hash;\n        });\n    }\n    /**\n     * Simulates a transaction on the Network, via a {@link IProvider}.\n     */\n    simulate(provider) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield provider.simulateTransaction(this);\n        });\n    }\n    /**\n     * Converts a transaction to a ready-to-broadcast object.\n     * Called internally by the {@link IProvider}.\n     */\n    toSendable() {\n        if (this.signature.isEmpty()) {\n            throw new errors.ErrTransactionNotSigned();\n        }\n        return this.toPlainObject();\n    }\n    /**\n     * Fetches a representation of the transaction (whether pending, processed or finalized), as found on the Network.\n     *\n     * @param fetcher The transaction fetcher to use\n     * @param cacheLocally Whether to cache the response locally, on the transaction object\n     * @param awaitNotarized Whether to wait for the transaction to be notarized\n     * @param withResults Whether to wait for the transaction results\n     */\n    getAsOnNetwork(fetcher, cacheLocally = true, awaitNotarized = true, withResults = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.hash.isEmpty()) {\n                throw new errors.ErrTransactionHashUnknown();\n            }\n            // For Smart Contract transactions, wait for their full execution & notarization before returning.\n            let isSmartContractTransaction = this.receiver.isContractAddress();\n            if (isSmartContractTransaction && awaitNotarized) {\n                yield this.awaitNotarized(fetcher);\n            }\n            let response = yield fetcher.getTransaction(this.hash, this.sender, withResults);\n            if (cacheLocally) {\n                this.asOnNetwork = response;\n            }\n            return response;\n        });\n    }\n    /**\n     * Returns the cached representation of the transaction, as previously fetched using {@link Transaction.getAsOnNetwork}.\n     */\n    getAsOnNetworkCached() {\n        return this.asOnNetwork;\n    }\n    awaitSigned() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.signature.isEmpty()) {\n                return;\n            }\n            return new Promise((resolve, _reject) => {\n                this.onSigned.on(() => resolve());\n            });\n        });\n    }\n    awaitHashed() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hash.isEmpty()) {\n                return;\n            }\n            return new Promise((resolve, _reject) => {\n                this.onSigned.on(() => resolve());\n            });\n        });\n    }\n    /**\n     * Computes the current transaction fee based on the {@link NetworkConfig} and transaction properties\n     * @param networkConfig {@link NetworkConfig}\n     */\n    computeFee(networkConfig) {\n        let moveBalanceGas = networkConfig.MinGasLimit.valueOf() +\n            this.data.length() * networkConfig.GasPerDataByte.valueOf();\n        if (moveBalanceGas > this.gasLimit.valueOf()) {\n            throw new errors.ErrNotEnoughGas(this.gasLimit.valueOf());\n        }\n        let gasPrice = new bignumber_js_1.BigNumber(this.gasPrice.valueOf());\n        let feeForMove = new bignumber_js_1.BigNumber(moveBalanceGas).multipliedBy(gasPrice);\n        if (moveBalanceGas === this.gasLimit.valueOf()) {\n            return feeForMove;\n        }\n        let diff = new bignumber_js_1.BigNumber(this.gasLimit.valueOf() - moveBalanceGas);\n        let modifiedGasPrice = gasPrice.multipliedBy(new bignumber_js_1.BigNumber(networkConfig.GasPriceModifier.valueOf()));\n        let processingFee = diff.multipliedBy(modifiedGasPrice);\n        return feeForMove.plus(processingFee);\n    }\n    /**\n     * Awaits for a transaction to reach its \"pending\" state - that is, for the transaction to be accepted in the mempool.\n     * Performs polling against the provider, via a {@link TransactionWatcher}.\n     */\n    awaitPending(fetcher) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let watcher = new transactionWatcher_1.TransactionWatcher(this.hash, fetcher);\n            yield watcher.awaitPending(this.notifyStatusUpdate.bind(this));\n        });\n    }\n    /**\n     * Awaits for a transaction to reach its \"executed\" state - that is, for the transaction to be processed (whether with success or with errors).\n     * Performs polling against the provider, via a {@link TransactionWatcher}.\n     */\n    awaitExecuted(fetcher) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let watcher = new transactionWatcher_1.TransactionWatcher(this.hash, fetcher);\n            yield watcher.awaitExecuted(this.notifyStatusUpdate.bind(this));\n        });\n    }\n    notifyStatusUpdate(newStatus) {\n        let sameStatus = this.status.equals(newStatus);\n        this.onStatusUpdated.emit({ transaction: this });\n        if (!sameStatus) {\n            this.status = newStatus;\n            this.onStatusChanged.emit({ transaction: this });\n        }\n    }\n    awaitNotarized(fetcher) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let watcher = new transactionWatcher_1.TransactionWatcher(this.hash, fetcher);\n            yield watcher.awaitNotarized();\n        });\n    }\n}\nexports.Transaction = Transaction;\n/**\n * An abstraction for handling and computing transaction hashes.\n */\nclass TransactionHash extends hash_1.Hash {\n    constructor(hash) {\n        super(hash);\n    }\n    /**\n     * Computes the hash of a transaction.\n     * Not yet implemented.\n     */\n    static compute(transaction) {\n        let serializer = new proto_1.ProtoSerializer();\n        let buffer = serializer.serializeTransaction(transaction);\n        let hash = createTransactionHasher(TRANSACTION_HASH_LENGTH)\n            .update(buffer)\n            .digest(\"hex\");\n        return new TransactionHash(hash);\n    }\n}\nexports.TransactionHash = TransactionHash;\n/**\n * An abstraction for handling and interpreting the \"status\" field of a {@link Transaction}.\n */\nclass TransactionStatus {\n    /**\n     * Creates a new TransactionStatus object.\n     */\n    constructor(status) {\n        this.status = (status || \"\").toLowerCase();\n    }\n    /**\n     * Creates an unknown status.\n     */\n    static createUnknown() {\n        return new TransactionStatus(\"unknown\");\n    }\n    /**\n     * Returns whether the transaction is pending (e.g. in mempool).\n     */\n    isPending() {\n        return (this.status == \"received\" ||\n            this.status == \"pending\" ||\n            this.status == \"partially-executed\");\n    }\n    /**\n     * Returns whether the transaction has been executed (not necessarily with success).\n     */\n    isExecuted() {\n        return this.isSuccessful() || this.isInvalid();\n    }\n    /**\n     * Returns whether the transaction has been executed successfully.\n     */\n    isSuccessful() {\n        return (this.status == \"executed\" ||\n            this.status == \"success\" ||\n            this.status == \"successful\");\n    }\n    /**\n     * Returns whether the transaction has been executed, but with a failure.\n     */\n    isFailed() {\n        return (this.status == \"fail\" ||\n            this.status == \"failed\" ||\n            this.status == \"unsuccessful\" ||\n            this.isInvalid());\n    }\n    /**\n     * Returns whether the transaction has been executed, but marked as invalid (e.g. due to \"insufficient funds\").\n     */\n    isInvalid() {\n        return this.status == \"invalid\";\n    }\n    toString() {\n        return this.status;\n    }\n    valueOf() {\n        return this.status;\n    }\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        return this.status == other.status;\n    }\n}\nexports.TransactionStatus = TransactionStatus;\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}