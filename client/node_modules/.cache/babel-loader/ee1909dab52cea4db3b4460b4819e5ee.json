{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NumericalBinaryCodec = void 0;\n\nvar typesystem_1 = require(\"../typesystem\");\n\nvar utils_1 = require(\"./utils\");\n\nvar bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\n\nvar constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\n\n\nvar NumericalBinaryCodec = /*#__PURE__*/function () {\n  function NumericalBinaryCodec() {\n    _classCallCheck(this, NumericalBinaryCodec);\n  }\n\n  _createClass(NumericalBinaryCodec, [{\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var offset = 0;\n      var length = type.sizeInBytes;\n\n      if (!length) {\n        // Size of type is not known: arbitrary-size big integer.\n        // Therefore, we must read the length from the header.\n        offset = constants_1.SizeOfU32;\n        length = buffer.readUInt32BE(0);\n      }\n\n      var payload = buffer.slice(offset, offset + length);\n      var result = this.decodeTopLevel(payload, type);\n      var decodedLength = length + offset;\n      return [result, decodedLength];\n    }\n  }, {\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var payload = utils_1.cloneBuffer(buffer);\n      var empty = buffer.length == 0;\n\n      if (empty) {\n        return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n      }\n\n      var isPositive = !type.withSign || utils_1.isMsbZero(payload);\n\n      if (isPositive) {\n        var _value = utils_1.bufferToBigInt(payload);\n\n        return new typesystem_1.NumericalValue(type, _value);\n      } // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n\n\n      utils_1.flipBufferBitsInPlace(payload);\n      var value = utils_1.bufferToBigInt(payload);\n      var negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n      var negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n      return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(primitive) {\n      if (primitive.sizeInBytes) {\n        return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n      } // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n\n\n      var buffer = this.encodeTopLevel(primitive);\n      var length = Buffer.alloc(constants_1.SizeOfU32);\n      length.writeUInt32BE(buffer.length);\n      return Buffer.concat([length, buffer]);\n    }\n  }, {\n    key: \"encodeNestedFixedSize\",\n    value: function encodeNestedFixedSize(primitive, size) {\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(size, 0x00);\n      }\n\n      if (!primitive.withSign) {\n        var _buffer = utils_1.bigIntToBuffer(primitive.value);\n\n        var _paddingBytes = Buffer.alloc(size - _buffer.length, 0x00);\n\n        return Buffer.concat([_paddingBytes, _buffer]);\n      }\n\n      if (primitive.value.isPositive()) {\n        var _buffer2 = utils_1.bigIntToBuffer(primitive.value); // Fix ambiguity if any\n\n\n        if (utils_1.isMsbOne(_buffer2)) {\n          _buffer2 = utils_1.prependByteToBuffer(_buffer2, 0x00);\n        }\n\n        var _paddingBytes2 = Buffer.alloc(size - _buffer2.length, 0x00);\n\n        return Buffer.concat([_paddingBytes2, _buffer2]);\n      } // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n\n\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer); // Fix ambiguity if any\n\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n\n      var paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n      return Buffer.concat([paddingBytes, buffer]);\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(primitive) {\n      var withSign = primitive.withSign; // Nothing or Zero:\n\n      if (primitive.value.isZero()) {\n        return Buffer.alloc(0);\n      } // I don't care about the sign:\n\n\n      if (!withSign) {\n        return utils_1.bigIntToBuffer(primitive.value);\n      }\n\n      return this.encodePrimitive(primitive);\n    }\n  }, {\n    key: \"encodePrimitive\",\n    value: function encodePrimitive(primitive) {\n      // Positive:\n      if (primitive.value.isPositive()) {\n        var _buffer3 = utils_1.bigIntToBuffer(primitive.value); // Fix ambiguity if any\n\n\n        if (utils_1.isMsbOne(_buffer3)) {\n          _buffer3 = utils_1.prependByteToBuffer(_buffer3, 0x00);\n        }\n\n        return _buffer3;\n      } // Negative:\n      // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n\n\n      var valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n      var buffer = utils_1.bigIntToBuffer(valuePlusOne);\n      utils_1.flipBufferBitsInPlace(buffer); // Fix ambiguity if any\n\n      if (utils_1.isMsbZero(buffer)) {\n        buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n      }\n\n      return buffer;\n    }\n  }]);\n\n  return NumericalBinaryCodec;\n}();\n\nexports.NumericalBinaryCodec = NumericalBinaryCodec;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/numerical.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NumericalBinaryCodec = void 0;\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"./utils\");\nconst bignumber_js_1 = __importDefault(require(\"bignumber.js\"));\nconst constants_1 = require(\"./constants\");\n/**\n * Encodes and decodes \"NumericalValue\" objects\n * with respect to: {@link https://docs.elrond.com/developers/developer-reference/elrond-serialization-format/ | The Elrond Serialization Format}.\n */\nclass NumericalBinaryCodec {\n    decodeNested(buffer, type) {\n        let offset = 0;\n        let length = type.sizeInBytes;\n        if (!length) {\n            // Size of type is not known: arbitrary-size big integer.\n            // Therefore, we must read the length from the header.\n            offset = constants_1.SizeOfU32;\n            length = buffer.readUInt32BE(0);\n        }\n        let payload = buffer.slice(offset, offset + length);\n        let result = this.decodeTopLevel(payload, type);\n        let decodedLength = length + offset;\n        return [result, decodedLength];\n    }\n    decodeTopLevel(buffer, type) {\n        let payload = utils_1.cloneBuffer(buffer);\n        let empty = buffer.length == 0;\n        if (empty) {\n            return new typesystem_1.NumericalValue(type, new bignumber_js_1.default(0));\n        }\n        let isPositive = !type.withSign || utils_1.isMsbZero(payload);\n        if (isPositive) {\n            let value = utils_1.bufferToBigInt(payload);\n            return new typesystem_1.NumericalValue(type, value);\n        }\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/twos2bigint.go\n        utils_1.flipBufferBitsInPlace(payload);\n        let value = utils_1.bufferToBigInt(payload);\n        let negativeValue = value.multipliedBy(new bignumber_js_1.default(-1));\n        let negativeValueMinusOne = negativeValue.minus(new bignumber_js_1.default(1));\n        return new typesystem_1.NumericalValue(type, negativeValueMinusOne);\n    }\n    encodeNested(primitive) {\n        if (primitive.sizeInBytes) {\n            return this.encodeNestedFixedSize(primitive, primitive.sizeInBytes);\n        }\n        // Size is not known: arbitrary-size big integer. Therefore, we must emit the length (as U32) before the actual payload.\n        let buffer = this.encodeTopLevel(primitive);\n        let length = Buffer.alloc(constants_1.SizeOfU32);\n        length.writeUInt32BE(buffer.length);\n        return Buffer.concat([length, buffer]);\n    }\n    encodeNestedFixedSize(primitive, size) {\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(size, 0x00);\n        }\n        if (!primitive.withSign) {\n            const buffer = utils_1.bigIntToBuffer(primitive.value);\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            const paddingBytes = Buffer.alloc(size - buffer.length, 0x00);\n            return Buffer.concat([paddingBytes, buffer]);\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        const paddingBytes = Buffer.alloc(size - buffer.length, 0xff);\n        return Buffer.concat([paddingBytes, buffer]);\n    }\n    encodeTopLevel(primitive) {\n        let withSign = primitive.withSign;\n        // Nothing or Zero:\n        if (primitive.value.isZero()) {\n            return Buffer.alloc(0);\n        }\n        // I don't care about the sign:\n        if (!withSign) {\n            return utils_1.bigIntToBuffer(primitive.value);\n        }\n        return this.encodePrimitive(primitive);\n    }\n    encodePrimitive(primitive) {\n        // Positive:\n        if (primitive.value.isPositive()) {\n            let buffer = utils_1.bigIntToBuffer(primitive.value);\n            // Fix ambiguity if any\n            if (utils_1.isMsbOne(buffer)) {\n                buffer = utils_1.prependByteToBuffer(buffer, 0x00);\n            }\n            return buffer;\n        }\n        // Negative:\n        // Also see: https://github.com/ElrondNetwork/big-int-util/blob/master/twos-complement/bigint2twos.go\n        let valuePlusOne = primitive.value.plus(new bignumber_js_1.default(1));\n        let buffer = utils_1.bigIntToBuffer(valuePlusOne);\n        utils_1.flipBufferBitsInPlace(buffer);\n        // Fix ambiguity if any\n        if (utils_1.isMsbZero(buffer)) {\n            buffer = utils_1.prependByteToBuffer(buffer, 0xFF);\n        }\n        return buffer;\n    }\n}\nexports.NumericalBinaryCodec = NumericalBinaryCodec;\n//# sourceMappingURL=numerical.js.map"]},"metadata":{},"sourceType":"script"}