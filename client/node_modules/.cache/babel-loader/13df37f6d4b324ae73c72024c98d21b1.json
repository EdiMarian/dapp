{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletProvider = void 0;\n\nvar qs_1 = __importDefault(require(\"qs\"));\n\nvar constants_1 = require(\"./constants\");\n\nvar transaction_1 = require(\"../transaction\");\n\nvar errors_1 = require(\"../errors\");\n\nvar __1 = require(\"../\");\n\nvar signature_1 = require(\"../signature\");\n\nvar WalletProvider = /*#__PURE__*/function () {\n  /**\n   * Creates a new WalletProvider\n   * @param walletURL\n   */\n  function WalletProvider() {\n    var walletURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    _classCallCheck(this, WalletProvider);\n\n    this.walletUrl = walletURL;\n  }\n  /**\n   * Waits for the wallet iframe to ping that it has been initialised\n   */\n\n\n  _createClass(WalletProvider, [{\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", true);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n    /**\n     * Returns if the wallet iframe is up and running\n     */\n\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return true;\n    }\n    /**\n     * Unlike isInitialized, isConnected returns true if the user alredy went through the login process\n     *  and has the wallet session active\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", false);\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Fetches the login hook url and redirects the client to the wallet login.\n     */\n\n  }, {\n    key: \"login\",\n    value: function login(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var callbackUrl, token, redirect;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                callbackUrl = \"callbackUrl=\".concat(window.location.href);\n\n                if (options && options.callbackUrl) {\n                  callbackUrl = \"callbackUrl=\".concat(options.callbackUrl);\n                }\n\n                token = '';\n\n                if (options && options.token) {\n                  token = \"&token=\".concat(options.token);\n                }\n\n                redirect = \"\".concat(this.baseWalletUrl()).concat(constants_1.WALLET_PROVIDER_CONNECT_URL, \"?\").concat(callbackUrl).concat(token);\n                _context3.next = 7;\n                return new Promise(function (resolve) {\n                  setTimeout(function () {\n                    window.location.href = redirect;\n                    resolve(true);\n                  }, 10);\n                });\n\n              case 7:\n                return _context3.abrupt(\"return\", window.location.href);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n    * Fetches the logout hook url and redirects the client to the wallet logout.\n    */\n\n  }, {\n    key: \"logout\",\n    value: function logout(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var callbackUrl, redirect;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                callbackUrl = \"callbackUrl=\".concat(window.location.href);\n\n                if (options && options.callbackUrl) {\n                  callbackUrl = \"callbackUrl=\".concat(options.callbackUrl);\n                }\n\n                redirect = \"\".concat(this.baseWalletUrl()).concat(constants_1.WALLET_PROVIDER_DISCONNECT_URL, \"?\").concat(callbackUrl);\n                _context4.next = 5;\n                return new Promise(function (resolve) {\n                  setTimeout(function () {\n                    window.location.href = redirect;\n                    resolve(true);\n                  }, 10);\n                });\n\n              case 5:\n                return _context4.abrupt(\"return\", true);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Returns currently connected address. Empty string if not connected\n     */\n\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                throw new errors_1.ErrNotImplemented();\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n    }\n    /**\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n     *   the client to the send transaction hook\n     * @param transaction\n     * @param options\n     */\n\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(transaction, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var plainTransaction, url;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n                url = \"\".concat(this.baseWalletUrl()).concat(constants_1.WALLET_PROVIDER_SEND_TRANSACTION_URL, \"?\").concat(this.buildTransactionUrl(plainTransaction));\n                window.location.href = \"\".concat(url, \"&callbackUrl=\").concat(options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href);\n                return _context6.abrupt(\"return\", transaction);\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook\n     *\n     * @param transactions\n     * @param options\n     */\n\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(transactions, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var jsonToSend, url;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                jsonToSend = {};\n                transactions.map(function (tx) {\n                  var plainTx = WalletProvider.prepareWalletTransaction(tx);\n\n                  for (var txProp in plainTx) {\n                    if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {\n                      jsonToSend[txProp] = [];\n                    }\n\n                    jsonToSend[txProp].push(plainTx[txProp]);\n                  }\n                });\n                url = \"\".concat(this.baseWalletUrl()).concat(constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL, \"?\").concat(qs_1.default.stringify(jsonToSend));\n                window.location.href = \"\".concat(url, \"&callbackUrl=\").concat(options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href);\n                return _context7.abrupt(\"return\", transactions);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n     *   the client to the sign transaction hook\n     * @param transaction\n     * @param options\n     */\n\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var plainTransaction, url;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n                url = \"\".concat(this.baseWalletUrl()).concat(constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL, \"?\").concat(this.buildTransactionUrl(plainTransaction));\n                window.location.href = \"\".concat(url, \"&callbackUrl=\").concat(options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href);\n                return _context8.abrupt(\"return\", transaction);\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"getTransactionsFromWalletUrl\",\n    value: function getTransactionsFromWalletUrl() {\n      var transactions = [];\n      var urlParams = qs_1.default.parse(window.location.search.slice(1));\n\n      if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {\n        return transactions;\n      }\n\n      return WalletProvider.getTxSignReturnValue(urlParams);\n    }\n    /**\n     * Method will be available once the ElrondWallet hook will be implemented\n     * @param _\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(_) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                throw new errors_1.ErrNotImplemented();\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n    }\n  }, {\n    key: \"buildTransactionUrl\",\n    value: function buildTransactionUrl(transaction) {\n      var urlString = \"receiver=\".concat(transaction.receiver, \"&value=\").concat(transaction.value);\n\n      if (transaction.gasLimit) {\n        urlString += \"&gasLimit=\".concat(transaction.gasLimit);\n      }\n\n      if (transaction.gasPrice) {\n        urlString += \"&gasPrice=\".concat(transaction.gasPrice);\n      }\n\n      if (transaction.data) {\n        urlString += \"&data=\".concat(transaction.data);\n      }\n\n      if (transaction.nonce) {\n        urlString += \"&nonce=\".concat(transaction.nonce);\n      }\n\n      return urlString;\n    }\n  }, {\n    key: \"baseWalletUrl\",\n    value: function baseWalletUrl() {\n      var pathArray = this.walletUrl.split('/');\n      var protocol = pathArray[0];\n      var host = pathArray[2];\n      return protocol + '//' + host;\n    }\n  }], [{\n    key: \"isTxSignReturnSuccess\",\n    value: function isTxSignReturnSuccess(urlParams) {\n      return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;\n    }\n  }, {\n    key: \"getTxSignReturnValue\",\n    value: function getTxSignReturnValue(urlParams) {\n      var expectedProps = [\"nonce\", \"value\", \"receiver\", \"sender\", \"gasPrice\", \"gasLimit\", \"data\", \"chainID\", \"version\", \"signature\"];\n\n      for (var _i = 0, _expectedProps = expectedProps; _i < _expectedProps.length; _i++) {\n        var txProp = _expectedProps[_i];\n\n        if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {\n          throw new errors_1.ErrInvalidTxSignReturnValue();\n        }\n      }\n\n      var expectedLength = urlParams[\"nonce\"].length;\n\n      for (var _i2 = 0, _expectedProps2 = expectedProps; _i2 < _expectedProps2.length; _i2++) {\n        var _txProp = _expectedProps2[_i2];\n\n        if (urlParams[_txProp].length !== expectedLength) {\n          throw new errors_1.ErrInvalidTxSignReturnValue();\n        }\n      }\n\n      var transactions = [];\n\n      for (var i = 0; i < expectedLength; i++) {\n        var tx = new transaction_1.Transaction({\n          nonce: new __1.Nonce(urlParams[\"nonce\"][i]),\n          value: __1.Balance.fromString(urlParams[\"value\"][i]),\n          receiver: __1.Address.fromString(urlParams[\"receiver\"][i]),\n          gasPrice: new __1.GasPrice(parseInt(urlParams[\"gasPrice\"][i])),\n          gasLimit: new __1.GasLimit(parseInt(urlParams[\"gasLimit\"][i])),\n          data: new __1.TransactionPayload(urlParams[\"data\"][i]),\n          chainID: new __1.ChainID(urlParams[\"chainID\"][i]),\n          version: new __1.TransactionVersion(parseInt(urlParams[\"version\"][i]))\n        });\n        tx.applySignature(new signature_1.Signature(urlParams[\"signature\"][i]), __1.Address.fromString(urlParams[\"sender\"][i]));\n        transactions.push(tx);\n      }\n\n      return transactions;\n    }\n  }, {\n    key: \"prepareWalletTransaction\",\n    value: function prepareWalletTransaction(transaction) {\n      var plainTransaction = transaction.toPlainObject(); // We adjust the fields, in order to make them compatible with what the wallet expected\n\n      plainTransaction[\"nonce\"] = transaction.getNonce().valueOf();\n      plainTransaction[\"data\"] = transaction.getData().valueOf().toString();\n      plainTransaction[\"value\"] = transaction.getValue().toString();\n      plainTransaction[\"gasPrice\"] = transaction.getGasPrice().valueOf();\n      plainTransaction[\"gasLimit\"] = transaction.getGasLimit().valueOf();\n      return plainTransaction;\n    }\n  }]);\n\n  return WalletProvider;\n}();\n\nexports.WalletProvider = WalletProvider;","map":{"version":3,"sources":["../../src/dapp/walletProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletProvider = void 0;\nconst qs_1 = __importDefault(require(\"qs\"));\nconst constants_1 = require(\"./constants\");\nconst transaction_1 = require(\"../transaction\");\nconst errors_1 = require(\"../errors\");\nconst __1 = require(\"../\");\nconst signature_1 = require(\"../signature\");\nclass WalletProvider {\n    /**\n     * Creates a new WalletProvider\n     * @param walletURL\n     */\n    constructor(walletURL = '') {\n        this.walletUrl = walletURL;\n    }\n    /**\n     * Waits for the wallet iframe to ping that it has been initialised\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return true;\n        });\n    }\n    /**\n     * Returns if the wallet iframe is up and running\n     */\n    isInitialized() {\n        return true;\n    }\n    /**\n     * Unlike isInitialized, isConnected returns true if the user alredy went through the login process\n     *  and has the wallet session active\n     */\n    isConnected() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return false;\n        });\n    }\n    /**\n     * Fetches the login hook url and redirects the client to the wallet login.\n     */\n    login(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let callbackUrl = `callbackUrl=${window.location.href}`;\n            if (options && options.callbackUrl) {\n                callbackUrl = `callbackUrl=${options.callbackUrl}`;\n            }\n            let token = '';\n            if (options && options.token) {\n                token = `&token=${options.token}`;\n            }\n            const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_CONNECT_URL}?${callbackUrl}${token}`;\n            yield new Promise((resolve) => {\n                setTimeout(() => {\n                    window.location.href = redirect;\n                    resolve(true);\n                }, 10);\n            });\n            return window.location.href;\n        });\n    }\n    /**\n    * Fetches the logout hook url and redirects the client to the wallet logout.\n    */\n    logout(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let callbackUrl = `callbackUrl=${window.location.href}`;\n            if (options && options.callbackUrl) {\n                callbackUrl = `callbackUrl=${options.callbackUrl}`;\n            }\n            const redirect = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_DISCONNECT_URL}?${callbackUrl}`;\n            yield new Promise((resolve) => {\n                setTimeout(() => {\n                    window.location.href = redirect;\n                    resolve(true);\n                }, 10);\n            });\n            return true;\n        });\n    }\n    /**\n     * Returns currently connected address. Empty string if not connected\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    /**\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n     *   the client to the send transaction hook\n     * @param transaction\n     * @param options\n     */\n    sendTransaction(transaction, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SEND_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n            return transaction;\n        });\n    }\n    /**\n     * Packs an array of {$link Transaction} and redirects to the correct transaction sigining hook\n     *\n     * @param transactions\n     * @param options\n     */\n    signTransactions(transactions, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jsonToSend = {};\n            transactions.map(tx => {\n                let plainTx = WalletProvider.prepareWalletTransaction(tx);\n                for (let txProp in plainTx) {\n                    if (plainTx.hasOwnProperty(txProp) && !jsonToSend.hasOwnProperty(txProp)) {\n                        jsonToSend[txProp] = [];\n                    }\n                    jsonToSend[txProp].push(plainTx[txProp]);\n                }\n            });\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${qs_1.default.stringify(jsonToSend)}`;\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n            return transactions;\n        });\n    }\n    /**\n     * Packs a {@link Transaction} and fetches correct redirect URL from the wallet API. Then redirects\n     *   the client to the sign transaction hook\n     * @param transaction\n     * @param options\n     */\n    signTransaction(transaction, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let plainTransaction = WalletProvider.prepareWalletTransaction(transaction);\n            let url = `${this.baseWalletUrl()}${constants_1.WALLET_PROVIDER_SIGN_TRANSACTION_URL}?${this.buildTransactionUrl(plainTransaction)}`;\n            window.location.href = `${url}&callbackUrl=${options !== undefined && options.callbackUrl !== undefined ? options.callbackUrl : window.location.href}`;\n            return transaction;\n        });\n    }\n    getTransactionsFromWalletUrl() {\n        const transactions = [];\n        const urlParams = qs_1.default.parse(window.location.search.slice(1));\n        if (!WalletProvider.isTxSignReturnSuccess(urlParams)) {\n            return transactions;\n        }\n        return WalletProvider.getTxSignReturnValue(urlParams);\n    }\n    /**\n     * Method will be available once the ElrondWallet hook will be implemented\n     * @param _\n     */\n    signMessage(_) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    static isTxSignReturnSuccess(urlParams) {\n        return urlParams.hasOwnProperty(constants_1.WALLET_PROVIDER_CALLBACK_PARAM) && urlParams[constants_1.WALLET_PROVIDER_CALLBACK_PARAM] === constants_1.WALLET_PROVIDER_CALLBACK_PARAM_TX_SIGNED;\n    }\n    static getTxSignReturnValue(urlParams) {\n        const expectedProps = [\"nonce\", \"value\", \"receiver\", \"sender\", \"gasPrice\",\n            \"gasLimit\", \"data\", \"chainID\", \"version\", \"signature\"];\n        for (let txProp of expectedProps) {\n            if (!urlParams[txProp] || !Array.isArray(urlParams[txProp])) {\n                throw new errors_1.ErrInvalidTxSignReturnValue();\n            }\n        }\n        const expectedLength = urlParams[\"nonce\"].length;\n        for (let txProp of expectedProps) {\n            if (urlParams[txProp].length !== expectedLength) {\n                throw new errors_1.ErrInvalidTxSignReturnValue();\n            }\n        }\n        const transactions = [];\n        for (let i = 0; i < expectedLength; i++) {\n            let tx = new transaction_1.Transaction({\n                nonce: new __1.Nonce(urlParams[\"nonce\"][i]),\n                value: __1.Balance.fromString(urlParams[\"value\"][i]),\n                receiver: __1.Address.fromString(urlParams[\"receiver\"][i]),\n                gasPrice: new __1.GasPrice(parseInt(urlParams[\"gasPrice\"][i])),\n                gasLimit: new __1.GasLimit(parseInt(urlParams[\"gasLimit\"][i])),\n                data: new __1.TransactionPayload(urlParams[\"data\"][i]),\n                chainID: new __1.ChainID(urlParams[\"chainID\"][i]),\n                version: new __1.TransactionVersion(parseInt(urlParams[\"version\"][i])),\n            });\n            tx.applySignature(new signature_1.Signature(urlParams[\"signature\"][i]), __1.Address.fromString(urlParams[\"sender\"][i]));\n            transactions.push(tx);\n        }\n        return transactions;\n    }\n    static prepareWalletTransaction(transaction) {\n        let plainTransaction = transaction.toPlainObject();\n        // We adjust the fields, in order to make them compatible with what the wallet expected\n        plainTransaction[\"nonce\"] = transaction.getNonce().valueOf();\n        plainTransaction[\"data\"] = transaction.getData().valueOf().toString();\n        plainTransaction[\"value\"] = transaction.getValue().toString();\n        plainTransaction[\"gasPrice\"] = transaction.getGasPrice().valueOf();\n        plainTransaction[\"gasLimit\"] = transaction.getGasLimit().valueOf();\n        return plainTransaction;\n    }\n    buildTransactionUrl(transaction) {\n        let urlString = `receiver=${transaction.receiver}&value=${transaction.value}`;\n        if (transaction.gasLimit) {\n            urlString += `&gasLimit=${transaction.gasLimit}`;\n        }\n        if (transaction.gasPrice) {\n            urlString += `&gasPrice=${transaction.gasPrice}`;\n        }\n        if (transaction.data) {\n            urlString += `&data=${transaction.data}`;\n        }\n        if (transaction.nonce) {\n            urlString += `&nonce=${transaction.nonce}`;\n        }\n        return urlString;\n    }\n    baseWalletUrl() {\n        const pathArray = this.walletUrl.split('/');\n        const protocol = pathArray[0];\n        const host = pathArray[2];\n        return protocol + '//' + host;\n    }\n}\nexports.WalletProvider = WalletProvider;\n//# sourceMappingURL=walletProvider.js.map"]},"metadata":{},"sourceType":"script"}