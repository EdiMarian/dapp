{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\n\nvar codec_1 = require(\"./codec\");\n\nvar composite_1 = require(\"./typesystem/composite\");\n\nvar variadic_1 = require(\"./typesystem/variadic\");\n\nvar algebraic_1 = require(\"./typesystem/algebraic\");\n\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\n\nvar Codec = new codec_1.BinaryCodec();\n\nvar ArgSerializer = /*#__PURE__*/function () {\n  function ArgSerializer() {\n    _classCallCheck(this, ArgSerializer);\n  }\n\n  _createClass(ArgSerializer, [{\n    key: \"stringToValues\",\n    value:\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    function stringToValues(joinedString, parameters) {\n      var buffers = this.stringToBuffers(joinedString);\n      var values = this.buffersToValues(buffers, parameters);\n      return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n\n  }, {\n    key: \"stringToBuffers\",\n    value: function stringToBuffers(joinedString) {\n      // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n      return joinedString.split(exports.ArgumentsSeparator).map(function (item) {\n        return Buffer.from(item, \"hex\");\n      });\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n\n  }, {\n    key: \"buffersToValues\",\n    value: function buffersToValues(buffers, parameters) {\n      // TODO: Refactor, split (function is quite complex).\n      buffers = buffers || [];\n      var values = [];\n      var bufferIndex = 0;\n      var numBuffers = buffers.length;\n\n      for (var i = 0; i < parameters.length; i++) {\n        var parameter = parameters[i];\n        var type = parameter.type;\n        var value = readValue(type);\n        values.push(value);\n      } // This is a recursive function.\n\n\n      function readValue(type) {\n        // TODO: Use matchers.\n        if (type instanceof algebraic_1.OptionalType) {\n          var typedValue = readValue(type.getFirstTypeParameter());\n          return new algebraic_1.OptionalValue(type, typedValue);\n        } else if (type instanceof variadic_1.VariadicType) {\n          var typedValues = [];\n\n          while (!hasReachedTheEnd()) {\n            typedValues.push(readValue(type.getFirstTypeParameter()));\n          }\n\n          return new variadic_1.VariadicValue(type, typedValues);\n        } else if (type instanceof composite_1.CompositeType) {\n          var _typedValues = [];\n\n          var _iterator = _createForOfIteratorHelper(type.getTypeParameters()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var typeParameter = _step.value;\n\n              _typedValues.push(readValue(typeParameter));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          return new composite_1.CompositeValue(type, _typedValues);\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var _typedValue = decodeNextBuffer(type);\n\n          return _typedValue;\n        }\n      }\n\n      function decodeNextBuffer(type) {\n        if (hasReachedTheEnd()) {\n          return null;\n        }\n\n        var buffer = buffers[bufferIndex++];\n        var decodedValue = Codec.decodeTopLevel(buffer, type);\n        return decodedValue;\n      }\n\n      function hasReachedTheEnd() {\n        return bufferIndex >= numBuffers;\n      }\n\n      return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n\n  }, {\n    key: \"valuesToString\",\n    value: function valuesToString(values) {\n      var strings = this.valuesToStrings(values);\n      var argumentsString = strings.join(exports.ArgumentsSeparator);\n      var count = strings.length;\n      return {\n        argumentsString: argumentsString,\n        count: count\n      };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n\n  }, {\n    key: \"valuesToStrings\",\n    value: function valuesToStrings(values) {\n      var buffers = this.valuesToBuffers(values);\n      var strings = buffers.map(function (buffer) {\n        return buffer.toString(\"hex\");\n      });\n      return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n\n  }, {\n    key: \"valuesToBuffers\",\n    value: function valuesToBuffers(values) {\n      // TODO: Refactor, split (function is quite complex).\n      var buffers = [];\n\n      var _iterator2 = _createForOfIteratorHelper(values),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var value = _step2.value;\n          handleValue(value);\n        } // This is a recursive function. It appends to the \"buffers\" variable.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      function handleValue(value) {\n        // TODO: Use matchers.\n        if (value instanceof algebraic_1.OptionalValue) {\n          if (value.isSet()) {\n            handleValue(value.getTypedValue());\n          }\n        } else if (value instanceof variadic_1.VariadicValue) {\n          var _iterator3 = _createForOfIteratorHelper(value.getItems()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var item = _step3.value;\n              handleValue(item);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else if (value instanceof composite_1.CompositeValue) {\n          var _iterator4 = _createForOfIteratorHelper(value.getItems()),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _item = _step4.value;\n              handleValue(_item);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        } else {\n          // Non-composite (singular), non-variadic (fixed) type.\n          // The only branching without a recursive call.\n          var buffer = Codec.encodeTopLevel(value);\n          buffers.push(buffer);\n        }\n      }\n\n      return buffers;\n    }\n  }]);\n\n  return ArgSerializer;\n}();\n\nexports.ArgSerializer = ArgSerializer;","map":{"version":3,"sources":["../../src/smartcontracts/argSerializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgSerializer = exports.ArgumentsSeparator = void 0;\nconst codec_1 = require(\"./codec\");\nconst composite_1 = require(\"./typesystem/composite\");\nconst variadic_1 = require(\"./typesystem/variadic\");\nconst algebraic_1 = require(\"./typesystem/algebraic\");\nexports.ArgumentsSeparator = \"@\";\n/**\n * For the moment, this is the only codec used.\n */\nconst Codec = new codec_1.BinaryCodec();\nclass ArgSerializer {\n    /**\n     * Reads typed values from an arguments string (e.g. aa@bb@@cc), given parameter definitions.\n     */\n    stringToValues(joinedString, parameters) {\n        let buffers = this.stringToBuffers(joinedString);\n        let values = this.buffersToValues(buffers, parameters);\n        return values;\n    }\n    /**\n     * Reads raw buffers from an arguments string (e.g. aa@bb@@cc).\n     */\n    stringToBuffers(joinedString) {\n        // We also keep the zero-length buffers (they could encode missing options, Option<T>).\n        return joinedString.split(exports.ArgumentsSeparator).map(item => Buffer.from(item, \"hex\"));\n    }\n    /**\n     * Decodes a set of buffers into a set of typed values, given parameter definitions.\n     */\n    buffersToValues(buffers, parameters) {\n        // TODO: Refactor, split (function is quite complex).\n        buffers = buffers || [];\n        let values = [];\n        let bufferIndex = 0;\n        let numBuffers = buffers.length;\n        for (let i = 0; i < parameters.length; i++) {\n            let parameter = parameters[i];\n            let type = parameter.type;\n            let value = readValue(type);\n            values.push(value);\n        }\n        // This is a recursive function.\n        function readValue(type) {\n            // TODO: Use matchers.\n            if (type instanceof algebraic_1.OptionalType) {\n                let typedValue = readValue(type.getFirstTypeParameter());\n                return new algebraic_1.OptionalValue(type, typedValue);\n            }\n            else if (type instanceof variadic_1.VariadicType) {\n                let typedValues = [];\n                while (!hasReachedTheEnd()) {\n                    typedValues.push(readValue(type.getFirstTypeParameter()));\n                }\n                return new variadic_1.VariadicValue(type, typedValues);\n            }\n            else if (type instanceof composite_1.CompositeType) {\n                let typedValues = [];\n                for (const typeParameter of type.getTypeParameters()) {\n                    typedValues.push(readValue(typeParameter));\n                }\n                return new composite_1.CompositeValue(type, typedValues);\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let typedValue = decodeNextBuffer(type);\n                return typedValue;\n            }\n        }\n        function decodeNextBuffer(type) {\n            if (hasReachedTheEnd()) {\n                return null;\n            }\n            let buffer = buffers[bufferIndex++];\n            let decodedValue = Codec.decodeTopLevel(buffer, type);\n            return decodedValue;\n        }\n        function hasReachedTheEnd() {\n            return bufferIndex >= numBuffers;\n        }\n        return values;\n    }\n    /**\n     * Serializes a set of typed values into an arguments string (e.g. aa@bb@@cc).\n     */\n    valuesToString(values) {\n        let strings = this.valuesToStrings(values);\n        let argumentsString = strings.join(exports.ArgumentsSeparator);\n        let count = strings.length;\n        return { argumentsString, count };\n    }\n    /**\n     * Serializes a set of typed values into a set of strings.\n     */\n    valuesToStrings(values) {\n        let buffers = this.valuesToBuffers(values);\n        let strings = buffers.map(buffer => buffer.toString(\"hex\"));\n        return strings;\n    }\n    /**\n     * Serializes a set of typed values into a set of strings buffers.\n     * Variadic types and composite types might result into none, one or more buffers.\n     */\n    valuesToBuffers(values) {\n        // TODO: Refactor, split (function is quite complex).\n        let buffers = [];\n        for (const value of values) {\n            handleValue(value);\n        }\n        // This is a recursive function. It appends to the \"buffers\" variable.\n        function handleValue(value) {\n            // TODO: Use matchers.\n            if (value instanceof algebraic_1.OptionalValue) {\n                if (value.isSet()) {\n                    handleValue(value.getTypedValue());\n                }\n            }\n            else if (value instanceof variadic_1.VariadicValue) {\n                for (const item of value.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else if (value instanceof composite_1.CompositeValue) {\n                for (const item of value.getItems()) {\n                    handleValue(item);\n                }\n            }\n            else {\n                // Non-composite (singular), non-variadic (fixed) type.\n                // The only branching without a recursive call.\n                let buffer = Codec.encodeTopLevel(value);\n                buffers.push(buffer);\n            }\n        }\n        return buffers;\n    }\n}\nexports.ArgSerializer = ArgSerializer;\n//# sourceMappingURL=argSerializer.js.map"]},"metadata":{},"sourceType":"script"}