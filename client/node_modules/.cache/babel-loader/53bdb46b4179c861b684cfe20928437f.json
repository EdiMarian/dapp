{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\n\nvar errors = __importStar(require(\"../../errors\"));\n\nvar typesystem_1 = require(\"../typesystem\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar option_1 = require(\"./option\");\n\nvar primitive_1 = require(\"./primitive\");\n\nvar list_1 = require(\"./list\");\n\nvar struct_1 = require(\"./struct\");\n\nvar enum_1 = require(\"./enum\");\n\nvar tuple_1 = require(\"./tuple\");\n\nvar arrayVec_1 = require(\"./arrayVec\");\n\nvar BinaryCodec = /*#__PURE__*/function () {\n  function BinaryCodec() {\n    var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, BinaryCodec);\n\n    this.constraints = constraints || new BinaryCodecConstraints();\n    this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n    this.listCodec = new list_1.ListBinaryCodec(this);\n    this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n    this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n    this.structCodec = new struct_1.StructBinaryCodec(this);\n    this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n    this.enumCodec = new enum_1.EnumBinaryCodec(this);\n  }\n\n  _createClass(BinaryCodec, [{\n    key: \"decodeTopLevel\",\n    value: function decodeTopLevel(buffer, type) {\n      var _this = this;\n\n      this.constraints.checkBufferLength(buffer);\n      var typedValue = typesystem_1.onTypeSelect(type, {\n        onOption: function onOption() {\n          return _this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter());\n        },\n        onList: function onList() {\n          return _this.listCodec.decodeTopLevel(buffer, type);\n        },\n        onArray: function onArray() {\n          return _this.arrayCodec.decodeTopLevel(buffer, type);\n        },\n        onPrimitive: function onPrimitive() {\n          return _this.primitiveCodec.decodeTopLevel(buffer, type);\n        },\n        onStruct: function onStruct() {\n          return _this.structCodec.decodeTopLevel(buffer, type);\n        },\n        onTuple: function onTuple() {\n          return _this.tupleCodec.decodeTopLevel(buffer, type);\n        },\n        onEnum: function onEnum() {\n          return _this.enumCodec.decodeTopLevel(buffer, type);\n        }\n      });\n      return typedValue;\n    }\n  }, {\n    key: \"decodeNested\",\n    value: function decodeNested(buffer, type) {\n      var _this2 = this;\n\n      this.constraints.checkBufferLength(buffer);\n\n      var _typesystem_1$onTypeS = typesystem_1.onTypeSelect(type, {\n        onOption: function onOption() {\n          return _this2.optionCodec.decodeNested(buffer, type.getFirstTypeParameter());\n        },\n        onList: function onList() {\n          return _this2.listCodec.decodeNested(buffer, type);\n        },\n        onArray: function onArray() {\n          return _this2.arrayCodec.decodeNested(buffer, type);\n        },\n        onPrimitive: function onPrimitive() {\n          return _this2.primitiveCodec.decodeNested(buffer, type);\n        },\n        onStruct: function onStruct() {\n          return _this2.structCodec.decodeNested(buffer, type);\n        },\n        onTuple: function onTuple() {\n          return _this2.tupleCodec.decodeNested(buffer, type);\n        },\n        onEnum: function onEnum() {\n          return _this2.enumCodec.decodeNested(buffer, type);\n        }\n      }),\n          _typesystem_1$onTypeS2 = _slicedToArray(_typesystem_1$onTypeS, 2),\n          typedResult = _typesystem_1$onTypeS2[0],\n          decodedLength = _typesystem_1$onTypeS2[1];\n\n      return [typedResult, decodedLength];\n    }\n  }, {\n    key: \"encodeNested\",\n    value: function encodeNested(typedValue) {\n      var _this3 = this;\n\n      utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n      return typesystem_1.onTypedValueSelect(typedValue, {\n        onPrimitive: function onPrimitive() {\n          return _this3.primitiveCodec.encodeNested(typedValue);\n        },\n        onOption: function onOption() {\n          return _this3.optionCodec.encodeNested(typedValue);\n        },\n        onList: function onList() {\n          return _this3.listCodec.encodeNested(typedValue);\n        },\n        onArray: function onArray() {\n          return _this3.arrayCodec.encodeNested(typedValue);\n        },\n        onStruct: function onStruct() {\n          return _this3.structCodec.encodeNested(typedValue);\n        },\n        onTuple: function onTuple() {\n          return _this3.tupleCodec.encodeNested(typedValue);\n        },\n        onEnum: function onEnum() {\n          return _this3.enumCodec.encodeNested(typedValue);\n        }\n      });\n    }\n  }, {\n    key: \"encodeTopLevel\",\n    value: function encodeTopLevel(typedValue) {\n      var _this4 = this;\n\n      utils_1.guardType(\"value\", typesystem_1.TypedValue, typedValue, false);\n      utils_1.guardTrue(typedValue.getType().getCardinality().isSingular(), \"singular cardinality, thus encodable type\");\n      return typesystem_1.onTypedValueSelect(typedValue, {\n        onPrimitive: function onPrimitive() {\n          return _this4.primitiveCodec.encodeTopLevel(typedValue);\n        },\n        onOption: function onOption() {\n          return _this4.optionCodec.encodeTopLevel(typedValue);\n        },\n        onList: function onList() {\n          return _this4.listCodec.encodeTopLevel(typedValue);\n        },\n        onArray: function onArray() {\n          return _this4.arrayCodec.encodeTopLevel(typedValue);\n        },\n        onStruct: function onStruct() {\n          return _this4.structCodec.encodeTopLevel(typedValue);\n        },\n        onTuple: function onTuple() {\n          return _this4.tupleCodec.encodeTopLevel(typedValue);\n        },\n        onEnum: function onEnum() {\n          return _this4.enumCodec.encodeTopLevel(typedValue);\n        }\n      });\n    }\n  }]);\n\n  return BinaryCodec;\n}();\n\nexports.BinaryCodec = BinaryCodec;\n\nvar BinaryCodecConstraints = /*#__PURE__*/function () {\n  function BinaryCodecConstraints(init) {\n    _classCallCheck(this, BinaryCodecConstraints);\n\n    this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n    this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n  }\n\n  _createClass(BinaryCodecConstraints, [{\n    key: \"checkBufferLength\",\n    value: function checkBufferLength(buffer) {\n      if (buffer.length > this.maxBufferLength) {\n        throw new errors.ErrCodec(\"Buffer too large: \".concat(buffer.length, \" > \").concat(this.maxBufferLength));\n      }\n    }\n    /**\n     * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n     */\n\n  }, {\n    key: \"checkListLength\",\n    value: function checkListLength(length) {\n      if (length > this.maxListLength) {\n        throw new errors.ErrCodec(\"List too large: \".concat(length, \" > \").concat(this.maxListLength));\n      }\n    }\n  }]);\n\n  return BinaryCodecConstraints;\n}();\n\nexports.BinaryCodecConstraints = BinaryCodecConstraints;","map":{"version":3,"sources":["../../../src/smartcontracts/codec/binary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BinaryCodecConstraints = exports.BinaryCodec = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst typesystem_1 = require(\"../typesystem\");\nconst utils_1 = require(\"../../utils\");\nconst option_1 = require(\"./option\");\nconst primitive_1 = require(\"./primitive\");\nconst list_1 = require(\"./list\");\nconst struct_1 = require(\"./struct\");\nconst enum_1 = require(\"./enum\");\nconst tuple_1 = require(\"./tuple\");\nconst arrayVec_1 = require(\"./arrayVec\");\nclass BinaryCodec {\n    constructor(constraints = null) {\n        this.constraints = constraints || new BinaryCodecConstraints();\n        this.optionCodec = new option_1.OptionValueBinaryCodec(this);\n        this.listCodec = new list_1.ListBinaryCodec(this);\n        this.arrayCodec = new arrayVec_1.ArrayVecBinaryCodec(this);\n        this.primitiveCodec = new primitive_1.PrimitiveBinaryCodec(this);\n        this.structCodec = new struct_1.StructBinaryCodec(this);\n        this.tupleCodec = new tuple_1.TupleBinaryCodec(this);\n        this.enumCodec = new enum_1.EnumBinaryCodec(this);\n    }\n    decodeTopLevel(buffer, type) {\n        this.constraints.checkBufferLength(buffer);\n        let typedValue = typesystem_1.onTypeSelect(type, {\n            onOption: () => this.optionCodec.decodeTopLevel(buffer, type.getFirstTypeParameter()),\n            onList: () => this.listCodec.decodeTopLevel(buffer, type),\n            onArray: () => this.arrayCodec.decodeTopLevel(buffer, type),\n            onPrimitive: () => this.primitiveCodec.decodeTopLevel(buffer, type),\n            onStruct: () => this.structCodec.decodeTopLevel(buffer, type),\n            onTuple: () => this.tupleCodec.decodeTopLevel(buffer, type),\n            onEnum: () => this.enumCodec.decodeTopLevel(buffer, type),\n        });\n        return typedValue;\n    }\n    decodeNested(buffer, type) {\n        this.constraints.checkBufferLength(buffer);\n        let [typedResult, decodedLength] = typesystem_1.onTypeSelect(type, {\n            onOption: () => this.optionCodec.decodeNested(buffer, type.getFirstTypeParameter()),\n            onList: () => this.listCodec.decodeNested(buffer, type),\n            onArray: () => this.arrayCodec.decodeNested(buffer, type),\n            onPrimitive: () => this.primitiveCodec.decodeNested(buffer, type),\n            onStruct: () => this.structCodec.decodeNested(buffer, type),\n            onTuple: () => this.tupleCodec.decodeNested(buffer, type),\n            onEnum: () => this.enumCodec.decodeNested(buffer, type),\n        });\n        return [typedResult, decodedLength];\n    }\n    encodeNested(typedValue) {\n        utils_1.guardTrue(typedValue\n            .getType()\n            .getCardinality()\n            .isSingular(), \"singular cardinality, thus encodable type\");\n        return typesystem_1.onTypedValueSelect(typedValue, {\n            onPrimitive: () => this.primitiveCodec.encodeNested(typedValue),\n            onOption: () => this.optionCodec.encodeNested(typedValue),\n            onList: () => this.listCodec.encodeNested(typedValue),\n            onArray: () => this.arrayCodec.encodeNested(typedValue),\n            onStruct: () => this.structCodec.encodeNested(typedValue),\n            onTuple: () => this.tupleCodec.encodeNested(typedValue),\n            onEnum: () => this.enumCodec.encodeNested(typedValue),\n        });\n    }\n    encodeTopLevel(typedValue) {\n        utils_1.guardType(\"value\", typesystem_1.TypedValue, typedValue, false);\n        utils_1.guardTrue(typedValue\n            .getType()\n            .getCardinality()\n            .isSingular(), \"singular cardinality, thus encodable type\");\n        return typesystem_1.onTypedValueSelect(typedValue, {\n            onPrimitive: () => this.primitiveCodec.encodeTopLevel(typedValue),\n            onOption: () => this.optionCodec.encodeTopLevel(typedValue),\n            onList: () => this.listCodec.encodeTopLevel(typedValue),\n            onArray: () => this.arrayCodec.encodeTopLevel(typedValue),\n            onStruct: () => this.structCodec.encodeTopLevel(typedValue),\n            onTuple: () => this.tupleCodec.encodeTopLevel(typedValue),\n            onEnum: () => this.enumCodec.encodeTopLevel(typedValue),\n        });\n    }\n}\nexports.BinaryCodec = BinaryCodec;\nclass BinaryCodecConstraints {\n    constructor(init) {\n        this.maxBufferLength = (init === null || init === void 0 ? void 0 : init.maxBufferLength) || 4096;\n        this.maxListLength = (init === null || init === void 0 ? void 0 : init.maxListLength) || 1024;\n    }\n    checkBufferLength(buffer) {\n        if (buffer.length > this.maxBufferLength) {\n            throw new errors.ErrCodec(`Buffer too large: ${buffer.length} > ${this.maxBufferLength}`);\n        }\n    }\n    /**\n     * This constraint avoids computer-freezing decode bugs (e.g. due to invalid ABI or struct definitions).\n     */\n    checkListLength(length) {\n        if (length > this.maxListLength) {\n            throw new errors.ErrCodec(`List too large: ${length} > ${this.maxListLength}`);\n        }\n    }\n}\nexports.BinaryCodecConstraints = BinaryCodecConstraints;\n//# sourceMappingURL=binary.js.map"]},"metadata":{},"sourceType":"script"}