{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Struct = exports.StructType = void 0;\n\nvar fields_1 = require(\"./fields\");\n\nvar types_1 = require(\"./types\");\n\nvar StructType = /*#__PURE__*/function (_types_1$CustomType) {\n  _inherits(StructType, _types_1$CustomType);\n\n  var _super = _createSuper(StructType);\n\n  function StructType(name, fieldsDefinitions) {\n    var _this;\n\n    _classCallCheck(this, StructType);\n\n    _this = _super.call(this, name);\n    _this.fieldsDefinitions = [];\n    _this.fieldsDefinitions = fieldsDefinitions;\n    return _this;\n  }\n\n  _createClass(StructType, [{\n    key: \"getFieldsDefinitions\",\n    value: function getFieldsDefinitions() {\n      return this.fieldsDefinitions;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      var definitions = (json.fields || []).map(function (definition) {\n        return fields_1.FieldDefinition.fromJSON(definition);\n      });\n      return new StructType(json.name, definitions);\n    }\n  }]);\n\n  return StructType;\n}(types_1.CustomType);\n\nexports.StructType = StructType; // TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\n\nvar Struct = /*#__PURE__*/function (_types_1$TypedValue) {\n  _inherits(Struct, _types_1$TypedValue);\n\n  var _super2 = _createSuper(Struct);\n\n  /**\n   * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n   */\n  function Struct(type, fields) {\n    var _this2;\n\n    _classCallCheck(this, Struct);\n\n    _this2 = _super2.call(this, type);\n    _this2.fields = [];\n    _this2.fields = fields;\n\n    _this2.checkTyping();\n\n    return _this2;\n  }\n\n  _createClass(Struct, [{\n    key: \"checkTyping\",\n    value: function checkTyping() {\n      var type = this.getType();\n      var definitions = type.getFieldsDefinitions();\n      fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n  }, {\n    key: \"getFields\",\n    value: function getFields() {\n      return this.fields;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      var result = {};\n\n      var _iterator = _createForOfIteratorHelper(this.fields),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var field = _step.value;\n          result[field.name] = field.value.valueOf();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (!this.getType().equals(other.getType())) {\n        return false;\n      }\n\n      var selfFields = this.getFields();\n      var otherFields = other.getFields();\n      return fields_1.Fields.equals(selfFields, otherFields);\n    }\n  }]);\n\n  return Struct;\n}(types_1.TypedValue);\n\nexports.Struct = Struct;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/struct.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;IAEa,U;;;;;AAGT,sBAAY,IAAZ,EAA0B,iBAA1B,EAA8D;AAAA;;AAAA;;AAC1D,8BAAM,IAAN;AAHa,UAAA,iBAAA,GAAuC,EAAvC;AAIb,UAAK,iBAAL,GAAyB,iBAAzB;AAF0D;AAG7D;;;;WAOD,gCAAoB;AAChB,aAAO,KAAK,iBAAZ;AACH;;;WAPD,kBAAgB,IAAhB,EAAqD;AACjD,UAAI,WAAW,GAAG,CAAC,IAAI,CAAC,MAAL,IAAe,EAAhB,EAAoB,GAApB,CAAwB,UAAA,UAAU;AAAA,eAAI,QAAA,CAAA,eAAA,CAAgB,QAAhB,CAAyB,UAAzB,CAAJ;AAAA,OAAlC,CAAlB;AACA,aAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,IAApB,EAA0B,WAA1B,CAAP;AACH;;;;EAX2B,OAAA,CAAA,U;;AAAhC,OAAA,CAAA,UAAA,GAAA,UAAA,C,CAkBA;AACA;;IACa,M;;;;;AAGT;;AAEG;AACH,kBAAY,IAAZ,EAA8B,MAA9B,EAA6C;AAAA;;AAAA;;AACzC,gCAAM,IAAN;AANa,WAAA,MAAA,GAAkB,EAAlB;AAOb,WAAK,MAAL,GAAc,MAAd;;AAEA,WAAK,WAAL;;AAJyC;AAK5C;;;;WAEO,uBAAW;AACf,UAAI,IAAI,GAAe,KAAK,OAAL,EAAvB;AACA,UAAI,WAAW,GAAG,IAAI,CAAC,oBAAL,EAAlB;AACA,MAAA,QAAA,CAAA,MAAA,CAAO,WAAP,CAAmB,KAAK,MAAxB,EAAgC,WAAhC;AACH;;;WAED,qBAAS;AACL,aAAO,KAAK,MAAZ;AACH;;;WAED,mBAAO;AACH,UAAI,MAAM,GAAQ,EAAlB;;AADG,iDAGiB,KAAK,MAHtB;AAAA;;AAAA;AAGH,4DAAiC;AAAA,cAAtB,KAAsB;AAC7B,UAAA,MAAM,CAAC,KAAK,CAAC,IAAP,CAAN,GAAqB,KAAK,CAAC,KAAN,CAAY,OAAZ,EAArB;AACH;AALE;AAAA;AAAA;AAAA;AAAA;;AAOH,aAAO,MAAP;AACH;;;WAED,gBAAO,KAAP,EAAoB;AAChB,UAAI,CAAC,KAAK,OAAL,GAAe,MAAf,CAAsB,KAAK,CAAC,OAAN,EAAtB,CAAL,EAA6C;AACzC,eAAO,KAAP;AACH;;AAED,UAAI,UAAU,GAAG,KAAK,SAAL,EAAjB;AACA,UAAI,WAAW,GAAG,KAAK,CAAC,SAAN,EAAlB;AAEA,aAAO,QAAA,CAAA,MAAA,CAAO,MAAP,CAAc,UAAd,EAA0B,WAA1B,CAAP;AACH;;;;EA1CuB,OAAA,CAAA,U;;AAA5B,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Struct = exports.StructType = void 0;\nconst fields_1 = require(\"./fields\");\nconst types_1 = require(\"./types\");\nclass StructType extends types_1.CustomType {\n    constructor(name, fieldsDefinitions) {\n        super(name);\n        this.fieldsDefinitions = [];\n        this.fieldsDefinitions = fieldsDefinitions;\n    }\n    static fromJSON(json) {\n        let definitions = (json.fields || []).map(definition => fields_1.FieldDefinition.fromJSON(definition));\n        return new StructType(json.name, definitions);\n    }\n    getFieldsDefinitions() {\n        return this.fieldsDefinitions;\n    }\n}\nexports.StructType = StructType;\n// TODO: implement setField(), convenience method.\n// TODO: Hold fields in a map (by name), and use the order within \"field definitions\" to perform codec operations.\nclass Struct extends types_1.TypedValue {\n    /**\n     * Currently, one can only set fields at initialization time. Construction will be improved at a later time.\n     */\n    constructor(type, fields) {\n        super(type);\n        this.fields = [];\n        this.fields = fields;\n        this.checkTyping();\n    }\n    checkTyping() {\n        let type = this.getType();\n        let definitions = type.getFieldsDefinitions();\n        fields_1.Fields.checkTyping(this.fields, definitions);\n    }\n    getFields() {\n        return this.fields;\n    }\n    valueOf() {\n        let result = {};\n        for (const field of this.fields) {\n            result[field.name] = field.value.valueOf();\n        }\n        return result;\n    }\n    equals(other) {\n        if (!this.getType().equals(other.getType())) {\n            return false;\n        }\n        let selfFields = this.getFields();\n        let otherFields = other.getFields();\n        return fields_1.Fields.equals(selfFields, otherFields);\n    }\n}\nexports.Struct = Struct;\n//# sourceMappingURL=struct.js.map"]},"metadata":{},"sourceType":"script"}