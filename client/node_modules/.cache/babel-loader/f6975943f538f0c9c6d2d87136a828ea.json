{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletConnectProvider = void 0;\n\nvar client_1 = __importDefault(require(\"@walletconnect/client\"));\n\nvar address_1 = require(\"../address\");\n\nvar signature_1 = require(\"../signature\");\n\nvar constants_1 = require(\"./constants\");\n\nvar logger_1 = require(\"../logger\");\n\nvar errors_1 = require(\"../errors\");\n\nvar WalletConnectProvider = /*#__PURE__*/function () {\n  function WalletConnectProvider(httpProvider) {\n    var walletConnectBridge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var onClientConnect = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, WalletConnectProvider);\n\n    this.address = \"\";\n    this.signature = \"\";\n    this.provider = httpProvider;\n    this.walletConnectBridge = walletConnectBridge;\n    this.onClientConnect = onClientConnect;\n  }\n  /**\n   * Initiates wallet connect client.\n   */\n\n\n  _createClass(WalletConnectProvider, [{\n    key: \"init\",\n    value: function init() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this$walletConnector, account, _account$split, _account$split2, address, signature;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.walletConnector = new client_1.default({\n                  bridge: this.walletConnectBridge\n                });\n                this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n                this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n                this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n\n                if (!(this.walletConnector.connected && this.walletConnector.accounts.length)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _this$walletConnector = _slicedToArray(this.walletConnector.accounts, 1), account = _this$walletConnector[0];\n                _account$split = account.split(\".\"), _account$split2 = _slicedToArray(_account$split, 2), address = _account$split2[0], signature = _account$split2[1];\n                _context.next = 9;\n                return this.loginAccount(address, signature);\n\n              case 9:\n                return _context.abrupt(\"return\", true);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n\n  }, {\n    key: \"isInitialized\",\n    value: function isInitialized() {\n      return !!this.walletConnector;\n    }\n    /**\n     * Mocked function, returns isInitialized as an async function\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      var _this = this;\n\n      return new Promise(function (resolve, _) {\n        return resolve(_this.isInitialized());\n      });\n    }\n    /**\n     *\n     */\n\n  }, {\n    key: \"login\",\n    value: function login() {\n      var _a, _b, _c, _d;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.init();\n\n              case 3:\n                if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 6;\n                return this.walletConnector.killSession();\n\n              case 6:\n                logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n                return _context2.abrupt(\"return\", \"\");\n\n              case 8:\n                _context2.next = 10;\n                return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({\n                  chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID\n                });\n\n              case 10:\n                if ((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri) {\n                  _context2.next = 12;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", \"\");\n\n              case 12:\n                return _context2.abrupt(\"return\", (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri);\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 6;\n                return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n\n              case 6:\n                return _context3.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Fetches the wallet connect address\n     */\n\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                return _context4.abrupt(\"return\", this.address);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n    /**\n     * Fetches the wallet connect signature\n     */\n\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                return _context5.abrupt(\"return\", this.signature);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Signs and sends a transaction. Returns the transaction hash\n     * @param transaction\n     */\n\n  }, {\n    key: \"sendTransaction\",\n    value: function sendTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"sendTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                _context6.next = 5;\n                return this.signTransaction(transaction);\n\n              case 5:\n                transaction = _context6.sent;\n                _context6.next = 8;\n                return transaction.send(this.provider);\n\n              case 8:\n                return _context6.abrupt(\"return\", transaction);\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Method will be available once the Maiar wallet connect hook is implemented\n     * @param _\n     */\n\n  }, {\n    key: \"signMessage\",\n    value: function signMessage(_) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                throw new errors_1.ErrNotImplemented();\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n\n  }, {\n    key: \"signTransaction\",\n    value: function signTransaction(transaction) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var address, sig;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                _context8.next = 5;\n                return this.getAddress();\n\n              case 5:\n                address = _context8.sent;\n                _context8.next = 8;\n                return this.walletConnector.sendCustomRequest({\n                  method: \"erd_sign\",\n                  params: this.prepareWalletConnectMessage(transaction, address)\n                });\n\n              case 8:\n                sig = _context8.sent;\n\n                if (!(!sig || !sig.signature)) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n                throw new Error(\"Wallet Connect could not sign the transaction\");\n\n              case 12:\n                transaction.applySignature(new signature_1.Signature(sig.signature), new address_1.Address(address));\n                return _context8.abrupt(\"return\", transaction);\n\n              case 14:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n\n  }, {\n    key: \"signTransactions\",\n    value: function signTransactions(transactions) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this2 = this;\n\n        var address, params, signatures;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context9.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                _context9.next = 5;\n                return this.getAddress();\n\n              case 5:\n                address = _context9.sent;\n                params = transactions.map(function (transaction) {\n                  return _this2.prepareWalletConnectMessage(transaction, address);\n                });\n                _context9.next = 9;\n                return this.walletConnector.sendCustomRequest({\n                  method: \"erd_batch_sign\",\n                  params: params\n                });\n\n              case 9:\n                signatures = _context9.sent;\n\n                if (signatures) {\n                  _context9.next = 13;\n                  break;\n                }\n\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n                throw new Error(\"Wallet Connect could not sign the transactions\");\n\n              case 13:\n                if (!Array.isArray(signatures)) {\n                  _context9.next = 19;\n                  break;\n                }\n\n                if (!(transactions.length !== signatures.length)) {\n                  _context9.next = 17;\n                  break;\n                }\n\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n                throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n\n              case 17:\n                transactions.map(function (transaction, key) {\n                  return transaction.applySignature(new signature_1.Signature(signatures[key].signature), new address_1.Address(address));\n                });\n                return _context9.abrupt(\"return\", transactions);\n\n              case 19:\n                transactions[0].applySignature(new signature_1.Signature(signatures.signature), new address_1.Address(address));\n                return _context9.abrupt(\"return\", transactions);\n\n              case 21:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n    /**\n     * Sends a custom method and params and returns the response object\n     */\n\n  }, {\n    key: \"sendCustomMessage\",\n    value: function sendCustomMessage(_ref) {\n      var method = _ref.method,\n          params = _ref.params;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var customMessageResponse;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this.walletConnector) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n\n              case 3:\n                _context10.next = 5;\n                return this.walletConnector.sendCustomRequest({\n                  method: method,\n                  params: params\n                });\n\n              case 5:\n                customMessageResponse = _context10.sent;\n\n                if (customMessageResponse) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n                throw new Error(\"Wallet Connect could not send the message\");\n\n              case 9:\n                return _context10.abrupt(\"return\", customMessageResponse);\n\n              case 10:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(error, _ref2) {\n      var params = _ref2.params;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var _params$0$accounts, account, _account$split3, _account$split4, address, signature;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (!error) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw error;\n\n              case 2:\n                if (!(!params || !params[0])) {\n                  _context11.next = 5;\n                  break;\n                }\n\n                logger_1.Logger.error(\"Wallet Connect missing payload\");\n                throw new Error(\"missing payload\");\n\n              case 5:\n                _params$0$accounts = _slicedToArray(params[0].accounts, 1), account = _params$0$accounts[0];\n                _account$split3 = account.split(\".\"), _account$split4 = _slicedToArray(_account$split3, 2), address = _account$split4[0], signature = _account$split4[1];\n                _context11.next = 9;\n                return this.loginAccount(address, signature);\n\n              case 9:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(error) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!error) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                throw error;\n\n              case 2:\n                this.onClientConnect.onClientLogout();\n\n              case 3:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"loginAccount\",\n    value: function loginAccount(address, signature) {\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!this.addressIsValid(address)) {\n                  _context13.next = 5;\n                  break;\n                }\n\n                this.address = address;\n\n                if (signature) {\n                  this.signature = signature;\n                }\n\n                this.onClientConnect.onClientLogin();\n                return _context13.abrupt(\"return\");\n\n              case 5:\n                logger_1.Logger.error(\"Wallet Connect invalid address \".concat(address));\n\n                if (!((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected)) {\n                  _context13.next = 9;\n                  break;\n                }\n\n                _context13.next = 9;\n                return (_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession();\n\n              case 9:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n  }, {\n    key: \"prepareWalletConnectMessage\",\n    value: function prepareWalletConnectMessage(transaction, address) {\n      return {\n        nonce: transaction.getNonce().valueOf(),\n        from: address,\n        to: transaction.getReceiver().toString(),\n        amount: transaction.getValue().toString(),\n        gasPrice: transaction.getGasPrice().valueOf().toString(),\n        gasLimit: transaction.getGasLimit().valueOf().toString(),\n        data: Buffer.from(transaction.getData().toString().trim()).toString(),\n        chainId: transaction.getChainID().valueOf(),\n        version: transaction.getVersion().valueOf()\n      };\n    }\n  }, {\n    key: \"addressIsValid\",\n    value: function addressIsValid(destinationAddress) {\n      try {\n        var addr = new address_1.Address(destinationAddress);\n        return !!addr;\n      } catch (_a) {\n        return false;\n      }\n    }\n  }]);\n\n  return WalletConnectProvider;\n}();\n\nexports.WalletConnectProvider = WalletConnectProvider;","map":{"version":3,"sources":["../../src/dapp/walletConnectProvider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletConnectProvider = void 0;\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\nconst address_1 = require(\"../address\");\nconst signature_1 = require(\"../signature\");\nconst constants_1 = require(\"./constants\");\nconst logger_1 = require(\"../logger\");\nconst errors_1 = require(\"../errors\");\nclass WalletConnectProvider {\n    constructor(httpProvider, walletConnectBridge = \"\", onClientConnect) {\n        this.address = \"\";\n        this.signature = \"\";\n        this.provider = httpProvider;\n        this.walletConnectBridge = walletConnectBridge;\n        this.onClientConnect = onClientConnect;\n    }\n    /**\n     * Initiates wallet connect client.\n     */\n    init() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.walletConnector = new client_1.default({\n                bridge: this.walletConnectBridge,\n            });\n            this.walletConnector.on(\"connect\", this.onConnect.bind(this));\n            this.walletConnector.on(\"session_update\", this.onDisconnect.bind(this));\n            this.walletConnector.on(\"disconnect\", this.onDisconnect.bind(this));\n            if (this.walletConnector.connected &&\n                this.walletConnector.accounts.length) {\n                const [account] = this.walletConnector.accounts;\n                const [address, signature] = account.split(\".\");\n                yield this.loginAccount(address, signature);\n            }\n            return true;\n        });\n    }\n    /**\n     * Returns true if init() was previously called successfully\n     */\n    isInitialized() {\n        return !!this.walletConnector;\n    }\n    /**\n     * Mocked function, returns isInitialized as an async function\n     */\n    isConnected() {\n        return new Promise((resolve, _) => resolve(this.isInitialized()));\n    }\n    /**\n     *\n     */\n    login() {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                yield this.init();\n            }\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield this.walletConnector.killSession();\n                logger_1.Logger.trace(\"WalletConnect login started but walletConnect not initialized\");\n                return \"\";\n            }\n            yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.createSession({ chainId: constants_1.WALLETCONNECT_ELROND_CHAIN_ID }));\n            if (!((_c = this.walletConnector) === null || _c === void 0 ? void 0 : _c.uri)) {\n                return \"\";\n            }\n            return (_d = this.walletConnector) === null || _d === void 0 ? void 0 : _d.uri;\n        });\n    }\n    /**\n     * Mocks a logout request by returning true\n     */\n    logout() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"logout: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession());\n            }\n            return true;\n        });\n    }\n    /**\n     * Fetches the wallet connect address\n     */\n    getAddress() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"getAddress: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            return this.address;\n        });\n    }\n    /**\n     * Fetches the wallet connect signature\n     */\n    getSignature() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"getSignature: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            return this.signature;\n        });\n    }\n    /**\n     * Signs and sends a transaction. Returns the transaction hash\n     * @param transaction\n     */\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"sendTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            transaction = yield this.signTransaction(transaction);\n            yield transaction.send(this.provider);\n            return transaction;\n        });\n    }\n    /**\n     * Method will be available once the Maiar wallet connect hook is implemented\n     * @param _\n     */\n    signMessage(_) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new errors_1.ErrNotImplemented();\n        });\n    }\n    /**\n     * Signs a transaction and returns it\n     * @param transaction\n     */\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"signTransaction: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const sig = yield this.walletConnector.sendCustomRequest({\n                method: \"erd_sign\",\n                params: this.prepareWalletConnectMessage(transaction, address)\n            });\n            if (!sig || !sig.signature) {\n                logger_1.Logger.error(\"signTransaction: Wallet Connect could not sign the transaction\");\n                throw new Error(\"Wallet Connect could not sign the transaction\");\n            }\n            transaction.applySignature(new signature_1.Signature(sig.signature), new address_1.Address(address));\n            return transaction;\n        });\n    }\n    /**\n     * Signs an array of transactions and returns it\n     * @param transactions\n     */\n    signTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const address = yield this.getAddress();\n            const params = transactions.map((transaction) => this.prepareWalletConnectMessage(transaction, address));\n            const signatures = yield this.walletConnector.sendCustomRequest({\n                method: \"erd_batch_sign\",\n                params\n            });\n            if (!signatures) {\n                logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions\");\n                throw new Error(\"Wallet Connect could not sign the transactions\");\n            }\n            if (Array.isArray(signatures)) {\n                if (transactions.length !== signatures.length) {\n                    logger_1.Logger.error(\"signTransactions: Wallet Connect could not sign the transactions. Invalid signatures.\");\n                    throw new Error(\"Wallet Connect could not sign the transactions. Invalid signatures.\");\n                }\n                transactions.map((transaction, key) => transaction.applySignature(new signature_1.Signature(signatures[key].signature), new address_1.Address(address)));\n                return transactions;\n            }\n            transactions[0].applySignature(new signature_1.Signature(signatures.signature), new address_1.Address(address));\n            return transactions;\n        });\n    }\n    /**\n     * Sends a custom method and params and returns the response object\n     */\n    sendCustomMessage({ method, params, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.walletConnector) {\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect not initialised, call init() first\");\n                throw new Error(\"Wallet Connect not initialised, call init() first\");\n            }\n            const customMessageResponse = yield this.walletConnector.sendCustomRequest({\n                method,\n                params,\n            });\n            if (!customMessageResponse) {\n                logger_1.Logger.error(\"sendCustomMessage: Wallet Connect could not send the message\");\n                throw new Error(\"Wallet Connect could not send the message\");\n            }\n            return customMessageResponse;\n        });\n    }\n    onConnect(error, { params }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (error) {\n                throw error;\n            }\n            if (!params || !params[0]) {\n                logger_1.Logger.error(\"Wallet Connect missing payload\");\n                throw new Error(\"missing payload\");\n            }\n            const { accounts: [account], } = params[0];\n            const [address, signature] = account.split(\".\");\n            yield this.loginAccount(address, signature);\n        });\n    }\n    onDisconnect(error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (error) {\n                throw error;\n            }\n            this.onClientConnect.onClientLogout();\n        });\n    }\n    loginAccount(address, signature) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.addressIsValid(address)) {\n                this.address = address;\n                if (signature) {\n                    this.signature = signature;\n                }\n                this.onClientConnect.onClientLogin();\n                return;\n            }\n            logger_1.Logger.error(`Wallet Connect invalid address ${address}`);\n            if ((_a = this.walletConnector) === null || _a === void 0 ? void 0 : _a.connected) {\n                yield ((_b = this.walletConnector) === null || _b === void 0 ? void 0 : _b.killSession());\n            }\n        });\n    }\n    prepareWalletConnectMessage(transaction, address) {\n        return {\n            nonce: transaction.getNonce().valueOf(),\n            from: address,\n            to: transaction.getReceiver().toString(),\n            amount: transaction.getValue().toString(),\n            gasPrice: transaction\n                .getGasPrice()\n                .valueOf()\n                .toString(),\n            gasLimit: transaction\n                .getGasLimit()\n                .valueOf()\n                .toString(),\n            data: Buffer.from(transaction\n                .getData()\n                .toString()\n                .trim()).toString(),\n            chainId: transaction.getChainID().valueOf(),\n            version: transaction.getVersion().valueOf(),\n        };\n    }\n    addressIsValid(destinationAddress) {\n        try {\n            const addr = new address_1.Address(destinationAddress);\n            return !!addr;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n}\nexports.WalletConnectProvider = WalletConnectProvider;\n//# sourceMappingURL=walletConnectProvider.js.map"]},"metadata":{},"sourceType":"script"}