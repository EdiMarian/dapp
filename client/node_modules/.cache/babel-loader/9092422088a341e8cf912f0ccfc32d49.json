{"ast":null,"code":"\"use strict\";\n\nvar _construct = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/construct\");\n\nvar _toConsumableArray = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tuple = exports.TupleType = void 0;\n\nvar errors = __importStar(require(\"../../errors\"));\n\nvar struct_1 = require(\"./struct\");\n\nvar fields_1 = require(\"./fields\");\n\nvar struct_2 = require(\"./struct\");\n\nvar TupleType = /*#__PURE__*/function (_struct_2$StructType) {\n  _inherits(TupleType, _struct_2$StructType);\n\n  var _super = _createSuper(TupleType);\n\n  function TupleType() {\n    _classCallCheck(this, TupleType);\n\n    for (var _len = arguments.length, typeParameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      typeParameters[_key] = arguments[_key];\n    }\n\n    return _super.call(this, TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n  }\n\n  _createClass(TupleType, null, [{\n    key: \"prepareName\",\n    value: function prepareName(typeParameters) {\n      var fields = typeParameters.map(function (type) {\n        return type.toString();\n      }).join(\", \");\n      var result = \"tuple\".concat(fields.length, \"<\").concat(fields, \">\");\n      return result;\n    }\n  }, {\n    key: \"prepareFieldDefinitions\",\n    value: function prepareFieldDefinitions(typeParameters) {\n      var result = typeParameters.map(function (type, i) {\n        return new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type);\n      });\n      return result;\n    }\n  }]);\n\n  return TupleType;\n}(struct_2.StructType);\n\nexports.TupleType = TupleType;\n\nfunction prepareFieldName(fieldIndex) {\n  return \"field\".concat(fieldIndex);\n} // TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\n\n\nvar Tuple = /*#__PURE__*/function (_struct_1$Struct) {\n  _inherits(Tuple, _struct_1$Struct);\n\n  var _super2 = _createSuper(Tuple);\n\n  function Tuple(type, fields) {\n    _classCallCheck(this, Tuple);\n\n    return _super2.call(this, type, fields);\n  }\n\n  _createClass(Tuple, null, [{\n    key: \"fromItems\",\n    value: function fromItems(items) {\n      if (items.length < 1) {\n        // TODO: Define a better error.\n        throw new errors.ErrTypingSystem(\"bad tuple items\");\n      }\n\n      var fieldsTypes = items.map(function (item) {\n        return item.getType();\n      });\n\n      var tupleType = _construct(TupleType, _toConsumableArray(fieldsTypes));\n\n      var fields = items.map(function (item, i) {\n        return new fields_1.Field(item, prepareFieldName(i));\n      });\n      return new Tuple(tupleType, fields);\n    }\n  }]);\n\n  return Tuple;\n}(struct_1.Struct);\n\nexports.Tuple = Tuple;","map":{"version":3,"sources":["../../../src/smartcontracts/typesystem/tuple.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;IAEa,S;;;;;AACT,uBAAqC;AAAA;;AAAA,sCAAtB,cAAsB;AAAtB,MAAA,cAAsB;AAAA;;AAAA,6BAC3B,SAAS,CAAC,WAAV,CAAsB,cAAtB,CAD2B,EACY,SAAS,CAAC,uBAAV,CAAkC,cAAlC,CADZ;AAEpC;;;;WAEO,qBAAmB,cAAnB,EAAyC;AAC7C,UAAI,MAAM,GAAW,cAAc,CAAC,GAAf,CAAmB,UAAA,IAAI;AAAA,eAAI,IAAI,CAAC,QAAL,EAAJ;AAAA,OAAvB,EAA4C,IAA5C,CAAiD,IAAjD,CAArB;AACA,UAAI,MAAM,kBAAW,MAAM,CAAC,MAAlB,cAA4B,MAA5B,MAAV;AACA,aAAO,MAAP;AACH;;;WAEO,iCAA+B,cAA/B,EAAqD;AACzD,UAAI,MAAM,GAAG,cAAc,CAAC,GAAf,CAAmB,UAAC,IAAD,EAAO,CAAP;AAAA,eAAa,IAAI,QAAA,CAAA,eAAJ,CAAoB,gBAAgB,CAAC,CAAD,CAApC,EAAyC,uBAAzC,EAAkE,IAAlE,CAAb;AAAA,OAAnB,CAAb;AACA,aAAO,MAAP;AACH;;;;EAd0B,QAAA,CAAA,U;;AAA/B,OAAA,CAAA,SAAA,GAAA,SAAA;;AAiBA,SAAS,gBAAT,CAA0B,UAA1B,EAA4C;AACxC,wBAAe,UAAf;AACH,C,CAED;AACA;AACA;;;IACa,K;;;;;AACT,iBAAY,IAAZ,EAA6B,MAA7B,EAA4C;AAAA;;AAAA,8BAClC,IADkC,EAC5B,MAD4B;AAE3C;;;;WAED,mBAAiB,KAAjB,EAAoC;AAChC,UAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AAClB;AACA,cAAM,IAAI,MAAM,CAAC,eAAX,CAA2B,iBAA3B,CAAN;AACH;;AAED,UAAI,WAAW,GAAG,KAAK,CAAC,GAAN,CAAU,UAAA,IAAI;AAAA,eAAI,IAAI,CAAC,OAAL,EAAJ;AAAA,OAAd,CAAlB;;AACA,UAAI,SAAS,cAAO,SAAP,qBAAoB,WAApB,EAAb;;AACA,UAAI,MAAM,GAAG,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD,EAAO,CAAP;AAAA,eAAa,IAAI,QAAA,CAAA,KAAJ,CAAU,IAAV,EAAgB,gBAAgB,CAAC,CAAD,CAAhC,CAAb;AAAA,OAAV,CAAb;AAEA,aAAO,IAAI,KAAJ,CAAU,SAAV,EAAqB,MAArB,CAAP;AACH;;;;EAhBsB,QAAA,CAAA,M;;AAA3B,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tuple = exports.TupleType = void 0;\nconst errors = __importStar(require(\"../../errors\"));\nconst struct_1 = require(\"./struct\");\nconst fields_1 = require(\"./fields\");\nconst struct_2 = require(\"./struct\");\nclass TupleType extends struct_2.StructType {\n    constructor(...typeParameters) {\n        super(TupleType.prepareName(typeParameters), TupleType.prepareFieldDefinitions(typeParameters));\n    }\n    static prepareName(typeParameters) {\n        let fields = typeParameters.map(type => type.toString()).join(\", \");\n        let result = `tuple${fields.length}<${fields}>`;\n        return result;\n    }\n    static prepareFieldDefinitions(typeParameters) {\n        let result = typeParameters.map((type, i) => new fields_1.FieldDefinition(prepareFieldName(i), \"anonymous tuple field\", type));\n        return result;\n    }\n}\nexports.TupleType = TupleType;\nfunction prepareFieldName(fieldIndex) {\n    return `field${fieldIndex}`;\n}\n// TODO: Perhaps add a common base class for Struct and Tuple, called FieldsHolder?\n// Or let Tuple be the base class, but have Struct as a specialization of it, \"named tuple\"?\n// Or leave as it is?\nclass Tuple extends struct_1.Struct {\n    constructor(type, fields) {\n        super(type, fields);\n    }\n    static fromItems(items) {\n        if (items.length < 1) {\n            // TODO: Define a better error.\n            throw new errors.ErrTypingSystem(\"bad tuple items\");\n        }\n        let fieldsTypes = items.map(item => item.getType());\n        let tupleType = new TupleType(...fieldsTypes);\n        let fields = items.map((item, i) => new fields_1.Field(item, prepareFieldName(i)));\n        return new Tuple(tupleType, fields);\n    }\n}\nexports.Tuple = Tuple;\n//# sourceMappingURL=tuple.js.map"]},"metadata":{},"sourceType":"script"}