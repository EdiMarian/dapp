{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/estar dapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StrictChecker = void 0;\n\nvar errors = __importStar(require(\"../errors\"));\n/**\n * An interaction checker that aims to be as strict as possible.\n * It is designed to catch programmer errors such as:\n *  - incorrect types of contract call arguments\n *  - errors related to calling \"non-payable\" functions with some value provided\n *  - gas estimation errors (not yet implemented)\n */\n\n\nvar StrictChecker = /*#__PURE__*/function () {\n  function StrictChecker() {\n    _classCallCheck(this, StrictChecker);\n  }\n\n  _createClass(StrictChecker, [{\n    key: \"checkInteraction\",\n    value: function checkInteraction(interaction) {\n      var definition = interaction.getEndpoint();\n      this.checkPayable(interaction, definition);\n      this.checkArguments(interaction, definition);\n    }\n  }, {\n    key: \"checkPayable\",\n    value: function checkPayable(interaction, definition) {\n      var hasValue = interaction.getValue().isSet();\n      var isPayableInEGLD = definition.modifiers.isPayableInEGLD();\n\n      if (hasValue && !isPayableInEGLD) {\n        throw new errors.ErrContractInteraction(\"cannot send EGLD value to non-payable\");\n      }\n    }\n  }, {\n    key: \"checkArguments\",\n    value: function checkArguments(interaction, definition) {\n      var formalArguments = definition.input;\n      var actualArguments = interaction.getArguments();\n      var numFormalArguments = formalArguments.length;\n      var numActualArguments = actualArguments.length;\n\n      if (numFormalArguments != numActualArguments) {\n        throw new errors.ErrContractInteraction(\"bad arguments, expected: \".concat(numFormalArguments, \", got: \").concat(numActualArguments));\n      } // TODO: discuss again, possibly redesign the handling of covariance / contravariance.\n\n\n      for (var i = 0; i < numFormalArguments; i++) {\n        var expectedType = formalArguments[i].type;\n        var argument = actualArguments[i];\n        var actualType = argument.getType(); // isAssignableFrom() is responsible to handle covariance and contravariance (depending on the class that overrides it).\n\n        var ok = expectedType.isAssignableFrom(actualType);\n\n        if (!ok) {\n          throw new errors.ErrContractInteraction(\"type mismatch at index \".concat(i, \", expected: \").concat(expectedType, \", got: \").concat(actualType));\n        }\n      }\n    }\n  }]);\n\n  return StrictChecker;\n}();\n\nexports.StrictChecker = StrictChecker;","map":{"version":3,"sources":["../../src/smartcontracts/strictChecker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,YAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;AAKA;;;;;;AAMG;;;IACU,a;;;;;;;WACT,0BAAiB,WAAjB,EAAyC;AACrC,UAAI,UAAU,GAAG,WAAW,CAAC,WAAZ,EAAjB;AAEA,WAAK,YAAL,CAAkB,WAAlB,EAA+B,UAA/B;AACA,WAAK,cAAL,CAAoB,WAApB,EAAiC,UAAjC;AACH;;;WAEO,sBAAa,WAAb,EAAuC,UAAvC,EAAqE;AACzE,UAAI,QAAQ,GAAG,WAAW,CAAC,QAAZ,GAAuB,KAAvB,EAAf;AACA,UAAI,eAAe,GAAG,UAAU,CAAC,SAAX,CAAqB,eAArB,EAAtB;;AAEA,UAAI,QAAQ,IAAI,CAAC,eAAjB,EAAkC;AAC9B,cAAM,IAAI,MAAM,CAAC,sBAAX,CAAkC,uCAAlC,CAAN;AACH;AACJ;;;WAEO,wBAAe,WAAf,EAAyC,UAAzC,EAAuE;AAC3E,UAAI,eAAe,GAAG,UAAU,CAAC,KAAjC;AACA,UAAI,eAAe,GAAG,WAAW,CAAC,YAAZ,EAAtB;AACA,UAAI,kBAAkB,GAAG,eAAe,CAAC,MAAzC;AACA,UAAI,kBAAkB,GAAG,eAAe,CAAC,MAAzC;;AAEA,UAAI,kBAAkB,IAAI,kBAA1B,EAA8C;AAC1C,cAAM,IAAI,MAAM,CAAC,sBAAX,oCAA8D,kBAA9D,oBAA0F,kBAA1F,EAAN;AACH,OAR0E,CAU3E;;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,kBAApB,EAAwC,CAAC,EAAzC,EAA6C;AACzC,YAAI,YAAY,GAAG,eAAe,CAAC,CAAD,CAAf,CAAmB,IAAtC;AACA,YAAI,QAAQ,GAAG,eAAe,CAAC,CAAD,CAA9B;AACA,YAAI,UAAU,GAAG,QAAQ,CAAC,OAAT,EAAjB,CAHyC,CAIzC;;AACA,YAAI,EAAE,GAAG,YAAY,CAAC,gBAAb,CAA8B,UAA9B,CAAT;;AAEA,YAAI,CAAC,EAAL,EAAS;AACL,gBAAM,IAAI,MAAM,CAAC,sBAAX,kCAA4D,CAA5D,yBAA4E,YAA5E,oBAAkG,UAAlG,EAAN;AACH;AACJ;AACJ;;;;;;AAxCL,OAAA,CAAA,aAAA,GAAA,aAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StrictChecker = void 0;\nconst errors = __importStar(require(\"../errors\"));\n/**\n * An interaction checker that aims to be as strict as possible.\n * It is designed to catch programmer errors such as:\n *  - incorrect types of contract call arguments\n *  - errors related to calling \"non-payable\" functions with some value provided\n *  - gas estimation errors (not yet implemented)\n */\nclass StrictChecker {\n    checkInteraction(interaction) {\n        let definition = interaction.getEndpoint();\n        this.checkPayable(interaction, definition);\n        this.checkArguments(interaction, definition);\n    }\n    checkPayable(interaction, definition) {\n        let hasValue = interaction.getValue().isSet();\n        let isPayableInEGLD = definition.modifiers.isPayableInEGLD();\n        if (hasValue && !isPayableInEGLD) {\n            throw new errors.ErrContractInteraction(\"cannot send EGLD value to non-payable\");\n        }\n    }\n    checkArguments(interaction, definition) {\n        let formalArguments = definition.input;\n        let actualArguments = interaction.getArguments();\n        let numFormalArguments = formalArguments.length;\n        let numActualArguments = actualArguments.length;\n        if (numFormalArguments != numActualArguments) {\n            throw new errors.ErrContractInteraction(`bad arguments, expected: ${numFormalArguments}, got: ${numActualArguments}`);\n        }\n        // TODO: discuss again, possibly redesign the handling of covariance / contravariance.\n        for (let i = 0; i < numFormalArguments; i++) {\n            let expectedType = formalArguments[i].type;\n            let argument = actualArguments[i];\n            let actualType = argument.getType();\n            // isAssignableFrom() is responsible to handle covariance and contravariance (depending on the class that overrides it).\n            let ok = expectedType.isAssignableFrom(actualType);\n            if (!ok) {\n                throw new errors.ErrContractInteraction(`type mismatch at index ${i}, expected: ${expectedType}, got: ${actualType}`);\n            }\n        }\n    }\n}\nexports.StrictChecker = StrictChecker;\n//# sourceMappingURL=strictChecker.js.map"]},"metadata":{},"sourceType":"script"}