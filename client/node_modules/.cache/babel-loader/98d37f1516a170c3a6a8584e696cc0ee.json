{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/ediichim/Documents/workspace/temp/delegation-dashboard.elrond.com/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentErrorContext = void 0;\n\nvar __1 = require(\"..\");\n\nvar ArgumentErrorContext = /*#__PURE__*/function () {\n  function ArgumentErrorContext(endpointName, argumentIndex, parameterDefinition) {\n    _classCallCheck(this, ArgumentErrorContext);\n\n    this.endpointName = endpointName;\n    this.argumentIndex = argumentIndex;\n    this.parameterDefinition = parameterDefinition;\n  }\n\n  _createClass(ArgumentErrorContext, [{\n    key: \"throwError\",\n    value: function throwError(specificError) {\n      throw new __1.ErrInvalidArgument(\"Error when converting arguments for endpoint (endpoint name: \".concat(this.endpointName, \", argument index: \").concat(this.argumentIndex, \", name: \").concat(this.parameterDefinition.name, \", type: \").concat(this.parameterDefinition.type, \")\\nNested error: \").concat(specificError));\n    }\n  }, {\n    key: \"convertError\",\n    value: function convertError(native, typeName) {\n      this.throwError(\"Can't convert argument (argument: \".concat(native, \", type \").concat(typeof native, \"), wanted type: \").concat(typeName, \")\"));\n    }\n  }, {\n    key: \"unhandledType\",\n    value: function unhandledType(functionName, type) {\n      this.throwError(\"Unhandled type (function: \".concat(functionName, \", type: \").concat(type, \")\"));\n    }\n  }, {\n    key: \"guardSameLength\",\n    value: function guardSameLength(native, valueTypes) {\n      native = native || [];\n\n      if (native.length != valueTypes.length) {\n        this.throwError(\"Incorrect composite type length: have \".concat(native.length, \", expected \").concat(valueTypes.length, \" (argument: \").concat(native, \")\"));\n      }\n    }\n  }, {\n    key: \"guardHasField\",\n    value: function guardHasField(native, fieldName) {\n      native = native || {};\n\n      if (!(fieldName in native)) {\n        this.throwError(\"Struct argument does not contain a field named \\\"\".concat(fieldName, \"\\\" (argument: \").concat(JSON.stringify(native), \")\"));\n      }\n    }\n  }]);\n\n  return ArgumentErrorContext;\n}();\n\nexports.ArgumentErrorContext = ArgumentErrorContext;","map":{"version":3,"sources":["../../src/smartcontracts/argumentErrorContext.ts"],"names":[],"mappings":";;;;;;;;;;;AACA,IAAA,GAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;IAEa,oB;AAKT,gCAAY,YAAZ,EAAkC,aAAlC,EAAyD,mBAAzD,EAAyG;AAAA;;AACrG,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,mBAAL,GAA2B,mBAA3B;AACH;;;;WAED,oBAAW,aAAX,EAAgC;AAC5B,YAAM,IAAI,GAAA,CAAA,kBAAJ,wEAAuF,KAAK,YAA5F,+BAA6H,KAAK,aAAlI,qBAA0J,KAAK,mBAAL,CAAyB,IAAnL,qBAAkM,KAAK,mBAAL,CAAyB,IAA3N,8BAAmP,aAAnP,EAAN;AACH;;;WAED,sBAAa,MAAb,EAA0B,QAA1B,EAA0C;AACtC,WAAK,UAAL,6CAAqD,MAArD,oBAAqE,OAAO,MAA5E,6BAAqG,QAArG;AACH;;;WAED,uBAAc,YAAd,EAAoC,IAApC,EAA8C;AAC1C,WAAK,UAAL,qCAA6C,YAA7C,qBAAoE,IAApE;AACH;;;WAED,yBAAmB,MAAnB,EAAkC,UAAlC,EAAiD;AAC7C,MAAA,MAAM,GAAG,MAAM,IAAI,EAAnB;;AACA,UAAI,MAAM,CAAC,MAAP,IAAiB,UAAU,CAAC,MAAhC,EAAwC;AACpC,aAAK,UAAL,iDAAyD,MAAM,CAAC,MAAhE,wBAAoF,UAAU,CAAC,MAA/F,yBAAoH,MAApH;AACH;AACJ;;;WAED,uBAAc,MAAd,EAA2B,SAA3B,EAA4C;AACxC,MAAA,MAAM,GAAG,MAAM,IAAI,EAAnB;;AACA,UAAI,EAAE,SAAS,IAAI,MAAf,CAAJ,EAA4B;AACxB,aAAK,UAAL,4DAAmE,SAAnE,2BAA4F,IAAI,CAAC,SAAL,CAAe,MAAf,CAA5F;AACH;AACJ;;;;;;AAnCL,OAAA,CAAA,oBAAA,GAAA,oBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ArgumentErrorContext = void 0;\nconst __1 = require(\"..\");\nclass ArgumentErrorContext {\n    constructor(endpointName, argumentIndex, parameterDefinition) {\n        this.endpointName = endpointName;\n        this.argumentIndex = argumentIndex;\n        this.parameterDefinition = parameterDefinition;\n    }\n    throwError(specificError) {\n        throw new __1.ErrInvalidArgument(`Error when converting arguments for endpoint (endpoint name: ${this.endpointName}, argument index: ${this.argumentIndex}, name: ${this.parameterDefinition.name}, type: ${this.parameterDefinition.type})\\nNested error: ${specificError}`);\n    }\n    convertError(native, typeName) {\n        this.throwError(`Can't convert argument (argument: ${native}, type ${typeof native}), wanted type: ${typeName})`);\n    }\n    unhandledType(functionName, type) {\n        this.throwError(`Unhandled type (function: ${functionName}, type: ${type})`);\n    }\n    guardSameLength(native, valueTypes) {\n        native = native || [];\n        if (native.length != valueTypes.length) {\n            this.throwError(`Incorrect composite type length: have ${native.length}, expected ${valueTypes.length} (argument: ${native})`);\n        }\n    }\n    guardHasField(native, fieldName) {\n        native = native || {};\n        if (!(fieldName in native)) {\n            this.throwError(`Struct argument does not contain a field named \"${fieldName}\" (argument: ${JSON.stringify(native)})`);\n        }\n    }\n}\nexports.ArgumentErrorContext = ArgumentErrorContext;\n//# sourceMappingURL=argumentErrorContext.js.map"]},"metadata":{},"sourceType":"script"}